#!/usr/bin/env python3
# three_body_3d_ns_dtg_v3_4_anchor.py
# 3D Three-body + drag(ν) + (opt) turbulence + DTG + (NEW) central anchor potential
# Merged from v3.3 with:
# - Optional central harmonic (center_k) and/or Plummer (center_GM, center_eps) anchor at origin
# - Energy accounting updated to include central potential
# - CLI flags to sweep anchor strength for quick "pseudo-4-body" experiments
#
# Notes
# -----
# * When center_k>0 or center_GM>0, the motion feels an extra conservative
#   potential centered at origin. This is a proxy for a light, fixed 4th body.
# * Harmonic:    U_center = 0.5 * sum_i (m_i * center_k * |r_i|^2)
# * Plummer:     U_center = - sum_i (G * M_center * m_i) / sqrt(|r_i|^2 + center_eps^2)
# * Forces: F_center = -∇U_center = -m_i * center_k * r_i  -  (G*M_center*m_i) * r_i / (|r_i|^2+eps^2)^{3/2}
# * All energy-based diagnostics (E, drift, E0) include U_center consistently.

import argparse, os, json, time, sys, platform, math
import numpy as np
import pandas as pd
from scipy.integrate import solve_ivp

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

DEFAULT_EPS = 1e-8

# ========================== Utilities ==========================
def unpack_state_bodies(s, N=3):
    s = np.asarray(s, float).reshape(-1)
    if s.size != 6*N:
        raise ValueError(f"state length must be 6N (= {6*N}), got {s.size}")
    pos = s[:3*N].reshape(3, N, order="F")
    vel = s[3*N:6*N].reshape(3, N, order="F")
    return pos, vel

def pack_state_bodies(pos, vel):
    if pos.shape != vel.shape or pos.shape[0] != 3:
        raise ValueError("pos/vel must be (3,N)")
    N = pos.shape[1]
    return np.concatenate([pos.reshape(3*N, order="F"),
                           vel.reshape(3*N, order="F")])

def split_state_with_theta(s, N=3):
    s = np.asarray(s, float).reshape(-1)
    body, theta = s[:-1], float(s[-1])
    pos, vel = unpack_state_bodies(body, N=N)
    return pos, vel, theta

def pairwise_dr(pos):
    # pos: (3,N)
    dr = pos[:, None, :] - pos[:, :, None]    # (3,N,N)
    r2 = np.sum(dr*dr, axis=0)                # (N,N)
    return dr, r2

# NEW: center-force helpers ---------------------------------------------------
def center_force(pos, masses, center_k=0.0, center_GM=0.0, center_eps=0.1):
    """Compute central (origin) force on each body, shape (3,N).
    F_harm = -m_i * center_k * r_i
    F_plum = -(G*M_center*m_i) * r_i / (|r_i|^2 + eps^2)^{3/2}
    Here, center_GM = G*M_center (already multiplied).
    """
    if (center_k == 0.0) and (center_GM == 0.0):
        return 0.0
    r2 = np.sum(pos*pos, axis=0)  # (N,)
    # harmonic part
    F_h = - (center_k * masses)[None, :] * pos  # (3,N)
    # plummer part
    invr3 = (r2 + center_eps**2) ** (-1.5)
    F_p = - (center_GM * masses)[None, :] * (pos * invr3[None, :])
    return F_h + F_p


def accelerations(pos, vel, G, masses, eps=DEFAULT_EPS,
                  nu_eff=0.0, turb_coeff=0.0, k_ctrl_eff=0.0, theta_dev=0.0,
                  center_GM=0.0, center_eps=0.0, center_k=0.0):
    N = pos.shape[1]
    dr, r2 = pairwise_dr(pos)
    r2 = r2 + eps*eps
    mask = ~np.eye(N, dtype=bool)
    inv_r3 = np.where(mask, r2**-1.5, 0.0)
    w = masses[None, :] * inv_r3
    grav = G * np.einsum('kij,ij->ki', dr, w)

    # dissipative / control
    visc = -nu_eff * vel
    turb = turb_coeff * np.sin(np.sum(pos*pos, axis=0))[None, :] * vel if turb_coeff else 0.0
    theta_dev_pos = np.maximum(theta_dev, 0.0)
    ctrl = -k_ctrl_eff * theta_dev_pos * vel

    # NEW: central anchor
    F_center = center_force(pos, masses, center_k=center_k, center_GM=center_GM, center_eps=center_eps)

    return grav + visc + turb + ctrl + F_center


def total_energy_body(s_body, G=1.0, masses=(1,1,1), eps=DEFAULT_EPS,
                      center_k=0.0, center_GM=0.0, center_eps=0.1):
    pos, vel = unpack_state_bodies(s_body, N=3)
    masses = np.asarray(masses, float)
    # Kinetic
    K = 0.5 * np.sum(masses * np.sum(vel*vel, axis=0))
    # Pairwise potential
    dr, r2 = pairwise_dr(pos)
    r = np.sqrt(r2 + eps*eps)
    iu = np.triu_indices(len(masses), 1)
    U_pairs = -G * np.sum(masses[iu[0]] * masses[iu[1]] / r[iu])
    # NEW: center potential energy (harmonic + Plummer)
    r2_self = np.sum(pos*pos, axis=0)  # (N,)
    U_center_h = 0.5 * np.sum(masses * center_k * r2_self)
    U_center_p = - np.sum(center_GM * masses / np.sqrt(r2_self + center_eps**2))
    return K + U_pairs + U_center_h + U_center_p


def make_ic(mode="exp2", alpha=1.0):
    if mode == "exp1":
        raw = [0,0,0, 0,0,0, 1,0,0, 0,0.6,0.1, -1,0,0, 0,-0.6,-0.1]
    elif mode == "exp2":
        raw = [0,0,0, 0,0,0, 1,0,0, 0,0.8,0.2, -1,0,0, 0,-0.5,-0.05]
    elif mode == "exp3":
        raw = [0,0,0, 0,0,0, 1,0,0, 0,1.0,0.4, -1,0,0, 0,-0.2,0.0]
    elif mode == "figure8":
        raw = [
            -0.97000436, 0.24308753, 0, 0.466203685, 0.43236573, 0,
             0.97000436,-0.24308753, 0, 0.466203685, 0.43236573, 0,
             0.0,        0.0,       0,-0.93240737,-0.86473146, 0
        ]
    else:
        raise ValueError("mode must be exp1|exp2|exp3|figure8")
    s = np.array(raw, float)
    pos = np.vstack([s[[0,6,12]], s[[1,7,13]], s[[2,8,14]]])
    vel = np.vstack([s[[3,9,15]], s[[4,10,16]], s[[5,11,17]]])
    vel *= alpha
    return pos, vel


def zero_com_and_momentum(pos, vel, masses):
    m = masses.reshape(1, -1)
    com = (pos*m).sum(axis=1)/m.sum()
    pos = pos - com.reshape(3,1)
    p = (vel*m).sum(axis=1, keepdims=True)
    vel = vel - p/m.sum()
    return pos, vel


def positions_from_sol_bodyY(Y, N=3):
    rows = np.arange(N)
    x_rows = 3*rows + 0; y_rows = 3*rows + 1; z_rows = 3*rows + 2
    return Y[x_rows, :], Y[y_rows, :], Y[z_rows, :]

def min_pair_distance(pos):
    _, r2 = pairwise_dr(pos)
    N = r2.shape[0]
    m = r2 + np.eye(N)*1e18
    return float(np.sqrt(np.min(m)))

def hold_true(x_bool, win):
    if win <= 1:
        return bool(np.any(x_bool))
    k = np.ones(int(win), dtype=int)
    c = np.convolve(x_bool.astype(int), k, mode='same')
    return bool(np.any(c >= win))

# -------- diagnostics helpers --------
def diag_planarity(z, tol=1e-3):
    zmax = float(np.max(np.abs(z)))
    return bool(zmax < tol), zmax

def diag_fig8_similarity_phase(x, y, eps=1e-12):
    """Figure-8 유사도(속도방향 위상각 기반). 작을수록 유사."""
    scores = []
    for i in range(3):
        dx = np.diff(x[i]); dy = np.diff(y[i])
        ang = np.arctan2(dy + 0.0, dx + eps)
        dang = np.unwrap(ang)
        z = (dang - dang.mean()) / (np.std(dang) + eps)
        scores.append(z)
    def pair_score(a,b):
        n = min(len(a), len(b)); a,b = a[:n], b[:n]
        return float(np.std(a-b))
    return pair_score(scores[0],scores[1]) + pair_score(scores[1],scores[2]) + pair_score(scores[0],scores[2])

# ================= Conservative RHS / Lyapunov =================
def rhs_body_conservative(t, s_body, args_rhs):
    G, masses, eps = args_rhs["G"], args_rhs["masses"], args_rhs["eps"]
    cK, cGM, cEps = args_rhs.get("center_k",0.0), args_rhs.get("center_GM",0.0), args_rhs.get("center_eps",0.1)
    pos, vel = unpack_state_bodies(s_body, N=3)
    acc = accelerations(pos, vel, G, masses, eps=eps,
                        nu_eff=0.0, turb_coeff=0.0, k_ctrl_eff=0.0, theta_dev=0.0,
                        center_k=cK, center_GM=cGM, center_eps=cEps)
    return pack_state_bodies(vel, acc)


def lyap_spectrum_benettin(s0_body, rhs_body, tmax=12.0, dt=0.002, k=3, args_rhs=None, seed=0):
    rng = np.random.default_rng(seed)
    n = s0_body.size
    Q = rng.normal(size=(n, k))
    Q, _ = np.linalg.qr(Q)
    lyap = np.zeros(k)
    t = 0.0
    s = s0_body.copy()
    while t < tmax - 1e-12:
        t_next = min(t + dt, tmax)
        sol = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                        (t, t_next), s, method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
        s = sol.y[:, -1]
        eps_fd = 1e-8
        Z = np.zeros_like(Q)
        for j in range(k):
            sol2 = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                             (t, t_next), s + eps_fd*Q[:, j],
                             method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
            Z[:, j] = (sol2.y[:, -1] - s)/eps_fd
        Q, R = np.linalg.qr(Z)
        lyap += np.log(np.abs(np.diag(R)) + 1e-300)
        t = t_next
    return lyap / tmax


def benettin_light_max(s0_body, rhs_body, dt=0.01, renorm_every=50, tmax=12.0, args_rhs=None, seed=0):
    rng = np.random.default_rng(seed)
    v = rng.normal(size=s0_body.size); v /= np.linalg.norm(v)
    s = s0_body.copy()
    lam_sum, t, d0 = 0.0, 0.0, 1e-8
    s_pert = s + d0 * v
    while t < tmax - 1e-12:
        t_next = min(t + renorm_every * dt, tmax)
        sol1 = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                         (t, t_next), s, method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
        sol2 = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                         (t, t_next), s_pert, method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
        s = sol1.y[:, -1]; s_pert = sol2.y[:, -1]
        d = np.linalg.norm(s_pert - s); d = d if d > 0 else 1e-300
        lam_sum += np.log(d/d0)
        v = (s_pert - s) / d
        s_pert = s + d0 * v
        t = t_next
    T = max(t, 1e-30)
    return lam_sum / T

# ========================== DTG RHS ==========================
class RHSParams:
    def __init__(self, G, masses, eps,
                 nu0=0.0, nu_max=1.0, turb_coeff=0.0,
                 theta0=1.0, alpha_dtg=0.4, beta_dtg=0.5, b_dtg=0.0, tau_theta=3.0,
                 theta_min=-1.5, theta_max=1.5, dtheta_max=0.05,
                 k_nu=0.0, k_nu_ed=0.0, k_ctrl=0.0, k_ctrl_e=0.0,
                 lyap_const=0.0, E0=None, soften_ctrl_when_clamped=True,
                 center_GM=0.0, center_eps=0.0, center_k=0.0):
        self.G, self.masses, self.eps = G, np.asarray(masses,float), float(eps)
        self.nu0, self.nu_max, self.turb_coeff = float(nu0), float(nu_max), float(turb_coeff)
        self.theta0 = float(theta0)
        self.alpha_dtg, self.beta_dtg, self.b_dtg = float(alpha_dtg), float(beta_dtg), float(b_dtg)
        self.tau_theta = float(tau_theta)
        self.theta_min, self.theta_max = float(theta_min), float(theta_max)
        self.dtheta_max = float(dtheta_max)
        self.k_nu, self.k_nu_ed = float(k_nu), float(k_nu_ed)
        self.k_ctrl, self.k_ctrl_e = float(k_ctrl), float(k_ctrl_e)
        self.lyap_const = float(lyap_const)
        self.E0 = None if E0 is None else float(E0)
        self.soften_ctrl_when_clamped = bool(soften_ctrl_when_clamped)
        self.center_GM = float(center_GM)
        self.center_eps = float(center_eps)
        self.center_k = float(center_k)
        # NEW: center anchor params


def rhs_with_dtg(t, s_all, prm: RHSParams):
    pos, vel, theta = split_state_with_theta(s_all, N=3)
    if prm.E0 is not None:
        E = total_energy_body(pack_state_bodies(pos, vel), prm.G, prm.masses, eps=prm.eps,
                               center_k=prm.center_k, center_GM=prm.center_GM, center_eps=prm.center_eps)
        ed = (E - prm.E0) / (abs(prm.E0) + 1e-15)
    else:
        ed = 0.0
    # target around theta0
    target = prm.theta0 + prm.alpha_dtg*ed - prm.beta_dtg*prm.lyap_const
    dtheta_raw = (target - theta) / max(prm.tau_theta, 1e-9)
    dtheta = np.clip(dtheta_raw, -prm.dtheta_max, prm.dtheta_max)

    theta_clamped = np.clip(theta, prm.theta_min, prm.theta_max)
    theta_dev = theta_clamped - prm.theta0
    nu_eff = np.clip(prm.nu0 + prm.k_nu*theta_dev + prm.k_nu_ed*ed, 0.0, prm.nu_max)
    k_ctrl_eff = prm.k_ctrl * (1.0 + prm.k_ctrl_e*abs(ed))
    if prm.soften_ctrl_when_clamped and (theta != theta_clamped):
        k_ctrl_eff *= 0.5
    # close-approach gating for control (strong only when rmin is small)
    rmin_now = min_pair_distance(pos)
    r_lo, r_hi = 0.03, 0.20
    g = np.clip((rmin_now - r_lo) / max(1e-12, (r_hi - r_lo)), 0.0, 1.0)
    k_ctrl_eff *= (1.0 - g)

    acc = accelerations(pos, vel, prm.G, prm.masses, eps=prm.eps,
                        nu_eff=nu_eff, turb_coeff=prm.turb_coeff,
                        k_ctrl_eff=k_ctrl_eff, theta_dev=theta_dev,
                        center_k=prm.center_k, center_GM=prm.center_GM, center_eps=prm.center_eps)
    return np.concatenate([pack_state_bodies(vel, acc), np.array([dtheta])])

# ========================== Core integration (adaptive optional) ==========================
def integrate_with_optional_adaptive(rhs, t0, t1, y0, args, prm, events):
    cur_t = float(t0)
    cur_y = y0.copy()
    cur_max_step = args.dt
    T_list = [cur_t]
    Y_list = [cur_y]
    escaped = collided = False
    t_escape = t_collision = None

    while cur_t < t1 - 1e-12:
        t_next = min(cur_t + args.chunk, t1)
        sol = solve_ivp(lambda tt, ss: rhs(tt, ss, prm),
                        (cur_t, t_next), cur_y, t_eval=None,
                        events=events,
                        method="DOP853", rtol=1e-9, atol=1e-12, max_step=cur_max_step)
        if sol.t.size > 1:
            T_list.extend(sol.t[1:])
            Y_list.extend(sol.y[:,1:].T)
        cur_t = float(T_list[-1]); cur_y = Y_list[-1]

        if len(sol.t_events) >= 1 and len(sol.t_events[0]) > 0:
            escaped = True; t_escape = float(sol.t_events[0][0]); break
        if len(sol.t_events) >= 2 and len(sol.t_events[1]) > 0:
            collided = True; t_collision = float(sol.t_events[1][0]); break

        if args.adaptive_step:
            pos, _, _ = split_state_with_theta(cur_y)
            rmin = min_pair_distance(pos)
            if rmin < args.adapt_r_trigger:
                cur_max_step = max(args.min_max_step, cur_max_step * args.adapt_factor)
            else:
                cur_max_step = min(args.dt, cur_max_step / max(1e-12, args.adapt_factor))

    return np.array(T_list), np.stack(Y_list, axis=1), escaped, t_escape, collided, t_collision

# ========================== Run simulation ==========================
def run_simulation(args):
    if args.eps < 1e-10:
        print(f"[warn] eps={args.eps:g} is very small; risk of blow-up near close encounters.")

    os.makedirs(args.out, exist_ok=True)
    for sub in ["figures", "data", "meta"]:
        os.makedirs(os.path.join(args.out, sub), exist_ok=True)

    masses = np.array([1.0,1.0,1.0], float)
    pos0, vel0 = make_ic(args.ic, args.alpha)
    if args.zero_init:
        pos0, vel0 = zero_com_and_momentum(pos0, vel0, masses)

    s0_body = pack_state_bodies(pos0, vel0)
    E0 = total_energy_body(s0_body, args.G, masses, eps=args.eps,
                           center_k=args.center_k, center_GM=args.center_GM, center_eps=args.center_eps)

    # Lyapunov
    lyap_top = None; lyap_spec = None
    if args.lyap_light:
        lyap_top = benettin_light_max(
            s0_body, rhs_body_conservative,
            dt=args.lyap_light_dt, renorm_every=args.lyap_light_renorm,
            tmax=max(6.0, args.tmax),
            args_rhs=dict(G=args.G, masses=masses, eps=args.eps,
                          center_k=args.center_k, center_GM=args.center_GM, center_eps=args.center_eps),
            seed=args.seed
        )
        print(f"[Lyapunov(top, light) ≈] {lyap_top:.6f}")
    if args.lyap_spectrum:
        lyap_spec = lyap_spectrum_benettin(
            s0_body, rhs_body_conservative,
            tmax=max(6.0, args.tmax), dt=args.dt, k=args.lyap_k,
            args_rhs=dict(G=args.G, masses=masses, eps=args.eps,
                          center_k=args.center_k, center_GM=args.center_GM, center_eps=args.center_eps),
            seed=args.seed
        )
        print("[Lyapunov spectrum (top-k)]", " ".join(f"{v:.6f}" for v in lyap_spec))

    if lyap_spec is not None:
        lyap_score = float(np.sum([v for v in lyap_spec if v > 0]))
        lyap_const = float(lyap_spec[0])
    elif lyap_top is not None:
        lyap_score = float(max(0.0, lyap_top))
        lyap_const = float(lyap_top)
    else:
        lyap_score = 0.0
        lyap_const = float(args.lyap_const)

    prm = RHSParams(
        G=args.G, masses=masses, eps=args.eps,
        nu0=args.nu0, nu_max=args.nu_max, turb_coeff=args.turb,
        theta0=args.theta0, alpha_dtg=args.alpha_dtg, beta_dtg=args.beta_dtg,
        b_dtg=args.b_dtg, tau_theta=args.tau_theta,
        theta_min=args.theta_min, theta_max=args.theta_max, dtheta_max=args.dtheta_max,
        k_nu=args.k_nu, k_nu_ed=args.k_nu_ed, k_ctrl=args.k_ctrl, k_ctrl_e=args.k_ctrl_e,
        lyap_const=lyap_const, E0=(E0 if args.dtg else None, center_GM=args.center_GM, center_eps=args.center_eps, center_k=args.center_k),
        soften_ctrl_when_clamped=not args.no_soften_when_clamped,
        center_k=args.center_k, center_GM=args.center_GM, center_eps=args.center_eps
    )

    t_eval = np.arange(0.0, args.tmax + 1e-12, args.dt)
    s_all = np.concatenate([s0_body, np.array([args.theta0])])

    # Events
    def event_escape(t, s):
        pos, _, _ = split_state_with_theta(s, N=3)
        r = np.sqrt(np.sum(pos*pos, axis=0))
        return float(args.R_esc - np.max(r))
    event_escape.terminal = True; event_escape.direction = -1.0

    def event_collision(t, s):
        pos, _, _ = split_state_with_theta(s, N=3)
        return min_pair_distance(pos) - args.r_collide
    event_collision.terminal = True; event_collision.direction = -1.0

    if args.adaptive_step:
        T_raw, Y_raw, esc, t_esc, col, t_col = integrate_with_optional_adaptive(
            rhs_with_dtg, 0.0, args.tmax, s_all, args, prm, (event_escape, event_collision)
        )
        Y_uniform = np.empty((Y_raw.shape[0], len(t_eval)))
        for i in range(Y_raw.shape[0]):
            Y_uniform[i] = np.interp(t_eval, T_raw, Y_raw[i])
        T, Y = t_eval, Y_uniform
        events_info = dict(escaped=esc, t_escape=t_esc, collided=col, t_collision=t_col)
    else:
        sol = solve_ivp(lambda tt, ss: rhs_with_dtg(tt, ss, prm),
                        (0.0, args.tmax), s_all, t_eval=t_eval,
                        events=(event_escape, event_collision),
                        method="DOP853", rtol=1e-9, atol=1e-12, max_step=args.dt)
        T, Y = sol.t, sol.y
        events_info = dict(
            escaped=(len(sol.t_events[0])>0),
            t_escape=(float(sol.t_events[0][0]) if len(sol.t_events[0]) else None),
            collided=(len(sol.t_events[1])>0),
            t_collision=(float(sol.t_events[1][0]) if len(sol.t_events[1]) else None),
        )

    bodyY, theta_hist = Y[:-1, :], Y[-1, :]
    x, y, z = positions_from_sol_bodyY(bodyY, N=3)

    # ===== Vectorized diagnostics =====
    def compute_diagnostics(bodyY, masses, G, eps, center_k, center_GM, center_eps):
        # bodyY: (18, T)
        pos = bodyY[:9, :].reshape(3, 3, -1, order="F")   # (xyz, body, T)
        vel = bodyY[9:18, :].reshape(3, 3, -1, order="F")
        # Kinetic
        speed2 = np.sum(vel**2, axis=0)                   # (body, T)
        K = 0.5 * np.sum(masses[:, None] * speed2, axis=0)  # (T,)
        # Pairwise potential
        dr = pos[:, None, :, :] - pos[:, :, None, :]      # (xyz, i, j, T)
        r2 = np.sum(dr**2, axis=0)                        # (i, j, T)
        r2_off = r2 + np.eye(3)[:, :, None] * 1e18
        r = np.sqrt(r2_off + eps*eps)
        iu = np.triu_indices(3, 1)
        pair_mass = (masses[iu[0]] * masses[iu[1]])[:, None]
        U_pairs = pair_mass / r[iu]                       # (pairs, T)
        U_pairs = -G * np.sum(U_pairs, axis=0)            # (T,)
        # Center potentials
        r2_self = np.sum(pos*pos, axis=0)                 # (body, T)
        U_center_h = 0.5 * np.sum(masses[:,None] * center_k * r2_self, axis=0)
        U_center_p = - np.sum(center_GM * masses[:,None] / np.sqrt(r2_self + center_eps**2), axis=0)
        E_series = K + U_pairs + U_center_h + U_center_p
        rmin_series = np.sqrt(np.min(r2_off, axis=(0,1))) # (T,)
        return E_series, rmin_series

    E_series, rmin_series = compute_diagnostics(bodyY, masses, args.G, args.eps,
                                                args.center_k, args.center_GM, args.center_eps)
    drift = (E_series - E0) / (abs(E0) + 1e-15)

    def pairdist(a,b):
        return np.sqrt((x[a]-x[b])**2 + (y[a]-y[b])**2 + (z[a]-z[b])**2)
    r12, r13, r23 = pairdist(0,1), pairdist(0,2), pairdist(1,2)
    bin_window = max(1, int(args.bin_hold/args.dt))
    binary_flag = any(hold_true(r < args.r_bin, bin_window) for r in [r12, r13, r23])

    # ===== CSVs =====
    df_main = pd.DataFrame({
        "t": T,
        "x1": x[0], "y1": y[0], "z1": z[0],
        "x2": x[1], "y2": y[1], "z2": z[1],
        "x3": x[2], "y3": y[2], "z3": z[2],
        "theta": theta_hist
    })
    csv_path = os.path.join(args.out, "data", f"threebody3d_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.csv")
    df_main.to_csv(csv_path, index=False)

    df_diag = pd.DataFrame({"t": T, "energy": E_series, "drift": drift,
                            "rmin": rmin_series, "r12": r12, "r13": r13, "r23": r23,
                            "theta": theta_hist})
    csv_diag = os.path.join(args.out, "data", f"diagnostics_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.csv")
    df_diag.to_csv(csv_diag, index=False)

    # ===== Plots =====
    if not args.no_plots:
        fig = plt.figure(figsize=(7,6)); ax = fig.add_subplot(111, projection="3d")
        ax.plot(x[0],y[0],z[0],label="Body 1"); ax.plot(x[1],y[1],z[1],label="Body 2"); ax.plot(x[2],y[2],z[2],label="Body 3")
        ax.set_xlabel("X"); ax.set_ylabel("Y"); ax.set_zlabel("Z")
        ax.set_title(f"3D Three-Body (ic={args.ic}, α={args.alpha}, dtg={args.dtg})")
        ax.legend();
        try: ax.set_box_aspect((1,1,1)); ax.set_proj_type('ortho')
        except Exception: pass
        ax.view_init(elev=args.elev, azim=args.azim)
        fig3d = os.path.join(args.out, "figures", f"threebody3d_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.png"); fig.savefig(fig3d, dpi=160); plt.close(fig)

        plt.figure(figsize=(6,5))
        for i, lab in enumerate(["Body 1","Body 2","Body 3"]):
            plt.plot(x[i], y[i], label=lab)
        plt.axis("equal"); plt.xlabel("X"); plt.ylabel("Y"); plt.legend()
        fig_xy = os.path.join(args.out, "figures", f"xy_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.png"); plt.savefig(fig_xy, dpi=160); plt.close()

        plt.figure(figsize=(7,4)); plt.plot(T, drift); plt.xlabel("Time"); plt.ylabel("Relative Energy Drift")
        fig_drift = os.path.join(args.out, "figures", f"energy_drift_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.png"); plt.savefig(fig_drift, dpi=160); plt.close()

        plt.figure(figsize=(7,4)); plt.plot(T, theta_hist); plt.xlabel("Time"); plt.ylabel("Theta (DTG)")
        fig_theta = os.path.join(args.out, "figures", f"theta_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.png"); plt.savefig(fig_theta, dpi=160); plt.close()

        plt.figure(figsize=(7,4)); plt.plot(T, rmin_series, label="rmin")
        plt.plot(T, r12, label="r12"); plt.plot(T, r13, label="r13"); plt.plot(T, r23, label="r23")
        plt.xlabel("Time"); plt.ylabel("Pair Distances"); plt.legend()
        fig_dist = os.path.join(args.out, "figures", f"distances_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.png"); plt.savefig(fig_dist, dpi=160); plt.close()
    else:
        fig3d = fig_drift = fig_theta = fig_xy = fig_dist = None

    # ===== High-level diagnostics =====
    planar, zmax = diag_planarity(z)
    fig8_phase = diag_fig8_similarity_phase(x, y)

    # θ activity (rad/s)
    dtheta = np.diff(theta_hist)
    dt_samp = float(np.mean(np.diff(T))) if len(T) > 1 else float(args.dt)
    theta_rate = float(np.mean(np.abs(dtheta)) / max(dt_samp, 1e-12))

    meta = dict(
        timestamp=time.strftime("%Y-%m-%d %H:%M:%S"),
        args=vars(args),
        E0=float(E0),
        lyap_top=float(lyap_top) if lyap_top is not None else None,
        lyap_spectrum=(list(map(float, lyap_spec)) if lyap_spec is not None else None),
        lyap_score=float(lyap_score),
        outputs=dict(csv=csv_path, csv_diagnostics=csv_diag,
                     fig3d=(None if args.no_plots else fig3d),
                     fig_xy=(None if args.no_plots else fig_xy),
                     drift=(None if args.no_plots else fig_drift),
                     theta=(None if args.no_plots else fig_theta),
                     distances=(None if args.no_plots else fig_dist)),
        events=events_info,
        binary=dict(flag=bool(binary_flag), r_bin=float(args.r_bin), hold=float(args.bin_hold)),
        end_state=dict(rmin=float(rmin_series[-1]),
                       drift=float(drift[-1]),
                       theta=float(theta_hist[-1]),
                       planar=planar, zmax=zmax,
                       fig8_phase=float(fig8_phase),
                       theta_activity=theta_rate)
    )

    meta["provenance"] = dict(
        python=sys.version, platform=platform.platform(),
        numpy=np.__version__, pandas=pd.__version__, cmd=" ".join(sys.argv)
    )
    try:
        import scipy
        meta["provenance"]["scipy"] = scipy.__version__
    except Exception:
        pass

    meta_path = os.path.join(args.out, "meta", f"meta_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.json")
    with open(meta_path, "w", encoding="utf-8") as f:
        json.dump(meta, f, ensure_ascii=False, indent=2)

    print(f"[OK] CSV   : {csv_path}")
    print(f"[OK] DIAG  : {csv_diag}")
    if meta["events"]["escaped"]:
        print(f"[event] escape at t≈{meta['events']['t_escape']:.3f}")
    if meta["events"]["collided"]:
        print(f"[event] collision at t≈{meta['events']['t_collision']:.3f}")
    if binary_flag:
        print(f"[info] binary formation detected (any pair r<{args.r_bin}, hold≥{args.bin_hold}s)")

    lam_list = (lyap_spec if lyap_spec is not None else ([lyap_top] if lyap_top is not None else []))
    return meta, csv_diag, lam_list, drift, theta_hist, planar, fig8_phase

# ========================== Analysis / Compare ==========================
def analyze_results(args, meta, csv_diag, lam, drift, theta_hist, planar, fig8_phase):
    max_drift = float(np.max(np.abs(drift)))
    drift_good = (max_drift < args.drift_threshold)

    df_diag = pd.read_csv(meta["outputs"]["csv_diagnostics"])  # for θ activity
    dt_samp = float(np.mean(np.diff(df_diag["t"]))) if len(df_diag["t"]) > 1 else float(args.dt)
    theta_rate = float(np.mean(np.abs(np.diff(theta_hist))) / max(dt_samp, 1e-12))
    theta_active = theta_rate > 0.01

    orbit_ok = planar or (fig8_phase < 1.0)
    lam_top = (lam[0] if lam else 0.0)
    lam_good = (lam_top < 0.5) if lam else False
    score = sum([drift_good, theta_active, orbit_ok, lam_good])
    verdict = "Success" if score >= 3 else ("Partial Success" if score >= 2 else "Failure")
    print(f"[Judgment] {verdict} (met {score}/4)"
          f" | drift_max={max_drift:.3g}"
          f" | theta_rate={theta_rate:.4f} rad/s ({theta_active})"
          f" | planar={planar}, fig8_phase={fig8_phase:.3f}"
          f" | lam_top={(lam_top if lam else float('nan')):.3f}")
    return verdict


def compare_runs(args, csv_b, csv_d, meta_b, meta_d):
    b = pd.read_csv(csv_b); d = pd.read_csv(csv_d)
    b_max = b["drift"].abs().max(); d_max = d["drift"].abs().max()
    imp_drift = 100*(b_max - d_max)/max(1e-12, b_max)
    esc_b = 0 if meta_b["events"]["escaped"] else 1
    esc_d = 0 if meta_d["events"]["escaped"] else 1
    imp_escape = 100*(esc_d - esc_b)
    col_b = 0 if meta_b["events"]["collided"] else 1
    col_d = 0 if meta_d["events"]["collided"] else 1
    imp_collision = 100*(col_d - col_b)
    lam_b = meta_b["lyap_top"] or (meta_b.get("lyap_spectrum",[0])[0] if meta_b.get("lyap_spectrum") else 0)
    lam_d = meta_d["lyap_top"] or (meta_d.get("lyap_spectrum",[0])[0] if meta_d.get("lyap_spectrum") else 0)
    imp_lyap = 100*(lam_b - lam_d)/max(1e-12, lam_b) if lam_b else 0
    dtheta = np.diff(d["theta"].values)
    dt_samp = float(np.mean(np.diff(d["t"].values))) if len(d["t"].values) > 1 else float(args.dt)
    theta_rate = float(np.mean(np.abs(dtheta)) / max(dt_samp, 1e-12))
    theta_active = theta_rate > 0.01
    score = sum(v > 30 for v in [imp_drift, imp_escape, imp_collision, imp_lyap]) + int(theta_active)
    verdict = "PASS" if score >= 2 else "NO-GAIN"
    return dict(
        verdict=verdict,
        drift_improve=float(imp_drift),
        escape_improve=float(imp_escape),
        collision_improve=float(imp_collision),
        lyap_improve=float(imp_lyap),
        theta_active=bool(theta_active)
    )

# ============================ CLI ============================
def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--ic", choices=["exp1","exp2","exp3","figure8"], default="exp2")
    ap.add_argument("--alpha", type=float, default=1.0)
    ap.add_argument("--tmax", type=float, default=20.0)
    ap.add_argument("--dt", type=float, default=0.002)
    ap.add_argument("--out", default="runs/out")
    ap.add_argument("--elev", type=float, default=20.0)
    ap.add_argument("--azim", type=float, default=-60.0)
    ap.add_argument("--eps", type=float, default=DEFAULT_EPS)
    ap.add_argument("--G", type=float, default=1.0)
    ap.add_argument("--seed", type=int, default=0)
    ap.add_argument("--zero_init", action="store_true")
    ap.add_argument("--no_plots", action="store_true")

    # drag / turbulence
    ap.add_argument("--nu0", type=float, default=0.003)
    ap.add_argument("--nu_max", type=float, default=1.0)
    ap.add_argument("--turb", type=float, default=0.0)

    # DTG
    ap.add_argument("--dtg", type=int, default=1)
    ap.add_argument("--theta0", type=float, default=1.0)
    ap.add_argument("--alpha_dtg", type=float, default=0.4)
    ap.add_argument("--beta_dtg", type=float, default=0.5)
    ap.add_argument("--b_dtg", type=float, default=0.0)
    ap.add_argument("--tau_theta", type=float, default=3.0)
    ap.add_argument("--theta_min", type=float, default=-1.5)
    ap.add_argument("--theta_max", type=float, default=1.5)
    ap.add_argument("--dtheta_max", type=float, default=0.05)
    ap.add_argument("--k_nu", type=float, default=0.0)
    ap.add_argument("--k_nu_ed", type=float, default=0.0)
    ap.add_argument("--k_ctrl", type=float, default=0.0)
    ap.add_argument("--k_ctrl_e", type=float, default=0.0)
    ap.add_argument("--lyap_const", type=float, default=0.0)
    ap.add_argument("--no_soften_when_clamped", action="store_true")

    # NEW: central anchor options
    ap.add_argument("--center_k", type=float, default=0.0, help="Harmonic anchor stiffness at origin")
    ap.add_argument("--center_GM", type=float, default=0.0, help="Plummer anchor GM at origin (G*M_center)")
    ap.add_argument("--center_eps", type=float, default=0.15, help="Plummer softening for center")

    # events / binary
    ap.add_argument("--R_esc", type=float, default=10.0)
    ap.add_argument("--r_collide", type=float, default=1e-3)
    ap.add_argument("--r_bin", type=float, default=0.5)
    ap.add_argument("--bin_hold", type=float, default=1.0)

    # adaptive max_step outer loop
    ap.add_argument("--adaptive_step", action="store_true")
    ap.add_argument("--adapt_r_trigger", type=float, default=0.02)
    ap.add_argument("--adapt_factor", type=float, default=0.3, help="cur_max_step *= factor ( <1 shrink )")
    ap.add_argument("--min_max_step", type=float, default=2e-4)
    ap.add_argument("--chunk", type=float, default=0.5, help="seconds per outer integration chunk")

    # Lyapunov options
    ap.add_argument("--lyap_light", action="store_true")
    ap.add_argument("--lyap_light_dt", type=float, default=0.01)
    ap.add_argument("--lyap_light_renorm", type=int, default=50)
    ap.add_argument("--lyap_spectrum", action="store_true")
    ap.add_argument("--lyap_k", type=int, default=3)

    # compare & scans
    ap.add_argument("--compare", action="store_true")
    ap.add_argument("--nu_scan", type=float, nargs="*", default=[])

    # analysis threshold
    ap.add_argument("--drift_threshold", type=float, default=0.05)

    args = ap.parse_args()

    if args.compare:
        results = []
        scan_list = [args.nu0] + [nu for nu in args.nu_scan if nu != args.nu0]
        for nu in (scan_list or [0.003]):
            b_args = argparse.Namespace(**vars(args))
            b_args.dtg = 0; b_args.nu0 = nu; b_args.out = os.path.join(args.out, f"baseline_nu{nu}")
            meta_b, csv_b, lam_b, drift_b, theta_b, planar_b, fig8_b = run_simulation(b_args)

            d_args = argparse.Namespace(**vars(args))
            d_args.dtg = 1; d_args.nu0 = nu; d_args.out = os.path.join(args.out, f"dtg_nu{nu}")
            meta_d, csv_d, lam_d, drift_d, theta_d, planar_d, fig8_d = run_simulation(d_args)

            res = compare_runs(args, meta_b["outputs"]["csv_diagnostics"], meta_d["outputs"]["csv_diagnostics"], meta_b, meta_d)
            res.update(nu=nu, lyap_b=(lam_b[0] if lam_b else None), lyap_d=(lam_d[0] if lam_d else None))
            results.append(res)
            print(f"[COMPARE nu={nu}] verdict={res['verdict']} | "
                  f"drift={res['drift_improve']:.1f}% | escape={res['escape_improve']:.1f}% | "
                  f"collision={res['collision_improve']:.1f}% | lyap={res['lyap_improve']:.1f}% | "
                  f"theta_active={res['theta_active']}")

        if results:
            best = max(results, key=lambda r: (r["drift_improve"] + r["escape_improve"] +
                                               r["collision_improve"] + r["lyap_improve"]))
            print(f"[BEST] nu={best['nu']}, verdict={best['verdict']}")
        return

    meta, csv_diag, lam, drift, theta_hist, planar, fig8_phase = run_simulation(args)
    analyze_results(args, meta, csv_diag, lam, drift, theta_hist, planar, fig8_phase)

if __name__ == "__main__":
    main()
