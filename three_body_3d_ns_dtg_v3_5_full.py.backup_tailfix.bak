#!/usr/bin/env python3
# three_body_3d_ns_dtg_v3_5_full.py
# 3D Three-body + drag(ν) + (opt) turbulence + DTG + central anchor potential
# - Hot kernels: Numba -> NumPy 폴백, (옵션) C++/pybind11 커널 우선 사용
# - DTG: signed/rectified, theta_init, energy/lyap 피드백, 공명항(res_amp,res_omega)
# - Integrators: DOP853(기본), --use_symplectic (K-D-K Verlet + dissipation split)
# - Potentials: Newton + Central(Harmonic + Plummer) + (옵션) Yukawa(repulsive/screened)
# - Outputs: CSV(main/diagnostics), figures, meta.json, 판정(Partial/Success)

#!/usr/bin/env python3
# three_body_3d_ns_dtg_v3_5_full.py

import argparse, os, json, time, sys, platform
import numpy as np
# [ADD] center-of-mass recentering helper
def com_recenter(state, mode="momentum"):
    """
    state: shape (3, 6): [[x,y,z,vx,vy,vz], ...], equal masses assumed
    mode : 'momentum' -> zero COM velocity only
           'full'     -> zero COM position & velocity
    """
    import numpy as np
    r = state[:, :3].copy()
    v = state[:, 3:].copy()
    m = np.ones(3)
    M = m.sum()
    Rcom = (m[:, None] * r).sum(axis=0) / M
    Vcom = (m[:, None] * v).sum(axis=0) / M
    if mode in ("momentum", "full"):
        v -= Vcom
    if mode == "full":
        r -= Rcom
    state[:, :3] = r
    state[:, 3:] = v
    return state
import pandas as pd
from scipy.integrate import solve_ivp

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

DEFAULT_EPS = 1e-8

# --- runtime backend flags (injected) ---
try:
    HAVE_NUMBA   # may already exist
except NameError:
    HAVE_NUMBA = False
try:
    CEXT
except NameError:
    CEXT = None  # external C/C++ ext fallback disabled by default
BACKEND = "Numba" if HAVE_NUMBA else "NumPy"


# 외부 C 확장(있으면 사용, 없으면 None)
CEXT = None

# ========== optional Numba ==========
HAVE_NUMBA = False
try:
    from numba import njit
    HAVE_NUMBA = True
except Exception:
    def njit(*args, **kwargs):
        # no-op decorator when numba not available
        def deco(f): 
            return f
        return deco
# ====================================

# ========================== Utilities ==========================
# ========================== Utilities ==========================
def unpack_state_bodies(s, N=3):
    s = np.asarray(s, float).reshape(-1)
    if s.size != 6*N:
        raise ValueError(f"state length must be 6N (= {6*N}), got {s.size}")
    pos = s[:3*N].reshape(3, N, order="F")
    vel = s[3*N:6*N].reshape(3, N, order="F")
    return pos, vel

def pack_state_bodies(pos, vel):
    if pos.shape != vel.shape or pos.shape[0] != 3:
        raise ValueError("pos/vel must be (3,N)")
    N = pos.shape[1]
    return np.concatenate([pos.reshape(3*N, order="F"),
                           vel.reshape(3*N, order="F")])

def split_state_with_theta(s, N=3):
    s = np.asarray(s, float).reshape(-1)
    body, theta = s[:-1], float(s[-1])
    pos, vel = unpack_state_bodies(body, N=N)
    return pos, vel, theta

def pairwise_dr(pos):
    dr = pos[:, None, :] - pos[:, :, None]    # (3,N,N)
    r2 = np.sum(dr*dr, axis=0)                # (N,N)
    return dr, r2

# ===== central anchor (origin) =====
def center_force_np(pos, masses, center_k=0.0, center_GM=0.0, center_eps=0.1):
    """F_center = -m_i*center_k*r_i  - (center_GM*m_i)*r_i/(|r_i|^2+eps^2)^{3/2}
       center_GM = G*M_center (already multiplied)"""
    if (center_k == 0.0) and (center_GM == 0.0):
        return 0.0
    r2 = np.sum(pos*pos, axis=0)  # (N,)
    F_h = - (center_k * masses)[None, :] * pos
    invr3 = (r2 + center_eps**2) ** (-1.5)
    F_p = - (center_GM * masses)[None, :] * (pos * invr3[None, :])
    return F_h + F_p

# ===== Yukawa force (repulsive/screened) =====
def yukawa_pair_force_np(dr, r, m_j, k, lam, repulsive=True):
    # Potential: V = sgn * k * exp(-lam r) / r  (sgn=+1: repulsive)
    # |F| = -dV/dr = sgn * k * exp(-lam r) * (1/r^2 + lam/r)
    if k == 0.0:
        return 0.0
    sgn = +1.0 if repulsive else -1.0
    fac = sgn * k * np.exp(-lam * r) * (1.0/(r*r) + lam/r) / r  # divide by r for unit vector multiply
    return (fac * m_j) * dr  # scale by mass like gravity

def accelerations_np_full(pos, vel, G, masses, eps=DEFAULT_EPS,
                          nu_eff=0.0, turb_coeff=0.0, k_ctrl_eff=0.0, theta_dev=0.0,
                          center_k=0.0, center_GM=0.0, center_eps=0.1,
                          ctrl_signed=False, yukawa_k=0.0, yukawa_lambda=0.5, yukawa_repulsive=True):
    """전체 힘(중력+점성+제어+난류+앵커+Yukawa)"""
    N = pos.shape[1]
    dr, r2 = pairwise_dr(pos)
    r2 = r2 + eps*eps
    mask = ~np.eye(N, dtype=bool)
    inv_r3 = np.where(mask, r2**-1.5, 0.0)
    w = masses[None, :] * inv_r3
    grav = G * np.einsum('kij,ij->ki', dr, w)

    # pairwise Yukawa
    if yukawa_k != 0.0:
        F_yuk = np.zeros_like(pos)
        for i in range(N):
            for j in range(N):
                if i == j: continue
                rij = np.sqrt(r2[i,j])
                if rij > 0:
                    F_yuk[:, i] += yukawa_pair_force_np(dr[:, i, j], rij, masses[j], yukawa_k, yukawa_lambda, yukawa_repulsive)
    else:
        F_yuk = 0.0

    visc = -nu_eff * vel
    if ctrl_signed:
        ctrl = -k_ctrl_eff * (theta_dev) * vel
    else:
        theta_dev_pos = np.maximum(theta_dev, 0.0)
        ctrl = -k_ctrl_eff * theta_dev_pos * vel
    turb = turb_coeff * np.sin(np.sum(pos*pos, axis=0))[None, :] * vel if turb_coeff else 0.0

    F_center = center_force_np(pos, masses, center_k=center_k, center_GM=center_GM, center_eps=center_eps)
    return grav + F_yuk + visc + turb + ctrl + F_center

def accelerations_np_conservative(pos, vel, G, masses, eps=DEFAULT_EPS,
                                  center_k=0.0, center_GM=0.0, center_eps=0.1,
                                  yukawa_k=0.0, yukawa_lambda=0.5, yukawa_repulsive=True):
    """보수계 힘(점성/제어/난류 제외) — 심플렉틱용"""
    N = pos.shape[1]
    dr, r2 = pairwise_dr(pos)
    r2 = r2 + eps*eps
    mask = ~np.eye(N, dtype=bool)
    inv_r3 = np.where(mask, r2**-1.5, 0.0)
    w = masses[None, :] * inv_r3
    grav = G * np.einsum('kij,ij->ki', dr, w)
    if yukawa_k != 0.0:
        F_yuk = np.zeros_like(pos)
        for i in range(N):
            for j in range(N):
                if i == j: continue
                rij = np.sqrt(r2[i,j])
                if rij > 0:
                    F_yuk[:, i] += yukawa_pair_force_np(dr[:, i, j], rij, masses[j], yukawa_k, yukawa_lambda, yukawa_repulsive)
    else:
        F_yuk = 0.0
    F_center = center_force_np(pos, masses, center_k=center_k, center_GM=center_GM, center_eps=center_eps)
    return grav + F_yuk + F_center

# ===== Numba hot kernels =====
@njit(cache=True, fastmath=True)
def min_pair_distance_numba(pos):  # pos: (3,N)
    N = pos.shape[1]
    m = 1.0e300
    for i in range(N):
        xi = pos[0,i]; yi = pos[1,i]; zi = pos[2,i]
        for j in range(i+1, N):
            dx = xi - pos[0,j]
            dy = yi - pos[1,j]
            dz = zi - pos[2,j]
            d2 = dx*dx + dy*dy + dz*dz
            if d2 < m: m = d2
    return np.sqrt(m)

@njit(cache=True, fastmath=True)
def accelerations_numba_full(pos, vel, G, masses, eps,
                             nu_eff, turb_coeff, k_ctrl_eff, theta_dev,
                             center_k, center_GM, center_eps, ctrl_signed,
                             yukawa_k, yukawa_lambda, yukawa_repulsive):
    N = pos.shape[1]
    acc = np.zeros_like(pos)
    for i in range(N):
        xi = pos[0,i]; yi = pos[1,i]; zi = pos[2,i]
        ax = 0.0; ay = 0.0; az = 0.0

        # pairwise gravity + Yukawa
        for j in range(N):
            if i == j: 
                continue
            dx = xi - pos[0,j]
            dy = yi - pos[1,j]
            dz = zi - pos[2,j]
            r2 = dx*dx + dy*dy + dz*dz + eps*eps
            r = np.sqrt(r2)
            invr3 = 1.0 / (r2 * r)
            s = -G * masses[j] * invr3
            ax += s*dx; ay += s*dy; az += s*dz

            if yukawa_k != 0.0:
                sgn = 1.0 if yukawa_repulsive else -1.0
                fac = sgn * yukawa_k * np.exp(-yukawa_lambda * r) * (1.0/(r*r) + yukawa_lambda/r) / r
                fac *= masses[j]
                ax += fac*dx; ay += fac*dy; az += fac*dz

        # viscous + control
        td = theta_dev if ctrl_signed else (theta_dev if theta_dev > 0.0 else 0.0)
        damp = nu_eff + k_ctrl_eff*td
        ax += -damp * vel[0,i]
        ay += -damp * vel[1,i]
        az += -damp * vel[2,i]

        # turbulence (optional)
        if turb_coeff != 0.0:
            s2 = xi*xi + yi*yi + zi*zi
            turb = turb_coeff * np.sin(s2)
            ax += turb*vel[0,i]; ay += turb*vel[1,i]; az += turb*vel[2,i]

        # center force (harmonic + Plummer)
        r2c = xi*xi + yi*yi + zi*zi
        ax += -(center_k * masses[i]) * xi
        ay += -(center_k * masses[i]) * yi
        az += -(center_k * masses[i]) * zi
        invr3c = 1.0 / ((r2c + center_eps*center_eps)**1.5)
        sC = -(center_GM * masses[i]) * invr3c
        ax += sC*xi; ay += sC*yi; az += sC*zi

        acc[0,i] = ax; acc[1,i] = ay; acc[2,i] = az
    return acc

@njit(cache=True, fastmath=True)
def accelerations_numba_conservative(pos, vel, G, masses, eps,
                                     center_k, center_GM, center_eps,
                                     yukawa_k, yukawa_lambda, yukawa_repulsive):
    N = pos.shape[1]
    acc = np.zeros_like(pos)
    for i in range(N):
        xi = pos[0,i]; yi = pos[1,i]; zi = pos[2,i]
        ax = 0.0; ay = 0.0; az = 0.0
        for j in range(N):
            if i == j: continue
            dx = xi - pos[0,j]
            dy = yi - pos[1,j]
            dz = zi - pos[2,j]
            r2 = dx*dx + dy*dy + dz*dz + eps*eps
            r = np.sqrt(r2)
            invr3 = 1.0 / (r2 * r)
            s = -G * masses[j] * invr3
            ax += s*dx; ay += s*dy; az += s*dz
            if yukawa_k != 0.0:
                sgn = 1.0 if yukawa_repulsive else -1.0
                fac = sgn * yukawa_k * np.exp(-yukawa_lambda * r) * (1.0/(r*r) + yukawa_lambda/r) / r
                fac *= masses[j]
                ax += fac*dx; ay += fac*dy; az += fac*dz
        # center
        r2c = xi*xi + yi*yi + zi*zi
        ax += -(center_k * masses[i]) * xi
        ay += -(center_k * masses[i]) * yi
        az += -(center_k * masses[i]) * zi
        invr3c = 1.0 / ((r2c + center_eps*center_eps)**1.5)
        sC = -(center_GM * masses[i]) * invr3c
        ax += sC*xi; ay += sC*yi; az += sC*zi
        acc[0,i] = ax; acc[1,i] = ay; acc[2,i] = az
    return acc

# 백엔드 선택기
def _acc_full(pos, vel, G, masses, eps,
              nu_eff, turb_coeff, k_ctrl_eff, theta_dev,
              center_k, center_GM, center_eps, ctrl_signed,
              yukawa_k, yukawa_lambda, yukawa_repulsive):
    if CEXT is not None:
        return CEXT.accelerations(pos, vel, G, masses, eps,
                                  nu_eff, turb_coeff, k_ctrl_eff, theta_dev,
                                  center_k, center_GM, center_eps, bool(ctrl_signed),
                                  yukawa_k, yukawa_lambda, bool(yukawa_repulsive))
    if HAVE_NUMBA:
        return accelerations_numba_full(pos, vel, G, masses, eps,
                                        nu_eff, turb_coeff, k_ctrl_eff, theta_dev,
                                        center_k, center_GM, center_eps, ctrl_signed,
                                        yukawa_k, yukawa_lambda, yukawa_repulsive)
    return accelerations_np_full(pos, vel, G, masses, eps,
                                 nu_eff, turb_coeff, k_ctrl_eff, theta_dev,
                                 center_k, center_GM, center_eps,
                                 ctrl_signed, yukawa_k, yukawa_lambda, yukawa_repulsive)

def _acc_cons(pos, vel, G, masses, eps,
              center_k, center_GM, center_eps, yukawa_k, yukawa_lambda, yukawa_repulsive):
    if CEXT is not None:
        return CEXT.accelerations_cons(pos, vel, G, masses, eps,
                                       center_k, center_GM, center_eps,
                                       yukawa_k, yukawa_lambda, bool(yukawa_repulsive))
    if HAVE_NUMBA:
        return accelerations_numba_conservative(pos, vel, G, masses, eps,
                                                center_k, center_GM, center_eps,
                                                yukawa_k, yukawa_lambda, yukawa_repulsive)
    return accelerations_np_conservative(pos, vel, G, masses, eps,
                                         center_k, center_GM, center_eps,
                                         yukawa_k, yukawa_lambda, yukawa_repulsive)

def _rmin(pos):
    """
    최소 거리 계산: CEXT(있으면) → Numba → NumPy 폴백
    pos shape: (3, N)
    """
    # 1) C 확장
    try:
        if CEXT is not None:
            return float(CEXT.min_pair_distance(pos))
    except NameError:
        pass
    except Exception:
        # CEXT가 있어도 호출 실패하면 폴백
        pass

    # 2) Numba
    try:
        if HAVE_NUMBA:
            return float(min_pair_distance_numba(pos))
    except NameError:
        pass
    except Exception:
        pass

    # 3) NumPy 폴백
    diffs = pos[:, None, :] - pos[:, :, None]  # (3,N,N)
    d2 = (diffs * diffs).sum(axis=0)           # (N,N)
    d2 = d2 + np.eye(d2.shape[0]) * 1e18       # 자기 자신 마스킹
    return float(np.sqrt(np.min(d2)))

# ================= Conservative RHS / Lyapunov =================
def rhs_body_conservative(t, s_body, args_rhs):
    G, masses, eps = args_rhs["G"], args_rhs["masses"], args_rhs["eps"]
    cK, cGM, cEps = args_rhs.get("center_k",0.0), args_rhs.get("center_GM",0.0), args_rhs.get("center_eps",0.1)
    yk = args_rhs.get("yukawa_k", 0.0); yl = args_rhs.get("yukawa_lambda", 0.5); yr = args_rhs.get("yukawa_repulsive", True)
    pos, vel = unpack_state_bodies(s_body, N=3)
    acc = _acc_cons(pos, vel, G, masses, eps, cK, cGM, cEps, yk, yl, yr)
    return pack_state_bodies(vel, acc)

def lyap_spectrum_benettin(s0_body, rhs_body, tmax=
# [ADD] next recenter time

12.0, dt=0.002, k=3, args_rhs=None, seed=0):
    rng = np.random.default_rng(seed)
    n = s0_body.size
    Q = rng.normal(size=(n, k)); Q, _ = np.linalg.qr(Q)
    lyap = np.zeros(k); t = 0.0; s = s0_body.copy()
    while t < tmax - 1e-12:
        t_next = min(t + dt, tmax)
        sol = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                        (t, t_next), s, method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
        s = sol.y[:, -1]
        eps_fd = 1e-8
        Z = np.zeros_like(Q)
        for j in range(k):
            sol2 = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                             (t, t_next), s + eps_fd*Q[:, j],
                             method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
            Z[:, j] = (sol2.y[:, -1] - s)/eps_fd
        Q, R = np.linalg.qr(Z)
        lyap += np.log(np.abs(np.diag(R)) + 1e-300)
        t = t_next
    return lyap / tmax

def benettin_light_max(s0_body, rhs_body, dt=0.01, renorm_every=50, tmax=12.0, args_rhs=None, seed=0):
    rng = np.random.default_rng(seed)
    v = rng.normal(size=s0_body.size); v /= np.linalg.norm(v)
    s = s0_body.copy()
    lam_sum, t, d0 = 0.0, 0.0, 1e-8
    s_pert = s + d0 * v
    while t < tmax - 1e-12:
        t_next = min(t + renorm_every * dt, tmax)
        sol1 = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                         (t, t_next), s, method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
        sol2 = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                         (t, t_next), s_pert, method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
        s = sol1.y[:, -1]; s_pert = sol2.y[:, -1]
        d = np.linalg.norm(s_pert - s); d = d if d > 0 else 1e-300
        lam_sum += np.log(d/d0)
        v = (s_pert - s) / d
        s_pert = s + d0 * v
        t = t_next
    T = max(t, 1e-30)
    return lam_sum / T

# ========================== DTG RHS ==========================
class RHSParams:
    def __init__(self, G, masses, eps,
                 nu0=0.0, nu_max=1.0, turb_coeff=0.0,
                 theta0=1.0, alpha_dtg=0.4, beta_dtg=0.5, b_dtg=0.0, tau_theta=3.0,
                 theta_min=-1.5, theta_max=1.5, dtheta_max=0.05,
                 k_nu=0.0, k_nu_ed=0.0, k_ctrl=0.0, k_ctrl_e=0.0,
                 lyap_const=0.0, E0=None, soften_ctrl_when_clamped=True,
                 center_k=0.0, center_GM=0.0, center_eps=0.1,
                 gate_floor=0.30, ctrl_signed=False,
                 yukawa_k=0.0, yukawa_lambda=0.5, yukawa_repulsive=True,
                 res_amp=0.0, res_omega=0.0, ed_scale=0.1, k_planar=0.0):
        self.G = float(G)
        self.masses = np.asarray(masses, float)
        self.eps = float(eps)

        self.nu0 = float(nu0)
        self.nu_max = float(nu_max)
        self.turb_coeff = float(turb_coeff)

        self.theta0 = float(theta0)
        self.alpha_dtg = float(alpha_dtg)
        self.beta_dtg = float(beta_dtg)
        self.b_dtg = float(b_dtg)
        self.tau_theta = float(tau_theta)

        self.theta_min = float(theta_min)
        self.theta_max = float(theta_max)
        self.dtheta_max = float(dtheta_max)

        self.k_nu = float(k_nu)
        self.k_nu_ed = float(k_nu_ed)
        self.k_ctrl = float(k_ctrl)
        self.k_ctrl_e = float(k_ctrl_e)

        self.lyap_const = float(lyap_const)
        self.E0 = None if E0 is None else float(E0)
        self.soften_ctrl_when_clamped = bool(soften_ctrl_when_clamped)

        self.center_k = float(center_k)
        self.center_GM = float(center_GM)
        self.center_eps = float(center_eps)

        self.gate_floor = float(gate_floor)
        self.ctrl_signed = bool(ctrl_signed)

        # clamp scale for energy deviation feedback
        self.ed_scale = float(ed_scale)

        self.yukawa_k = float(yukawa_k)
        self.yukawa_lambda = float(yukawa_lambda)
        self.yukawa_repulsive = bool(yukawa_repulsive)

        self.res_amp = float(res_amp)
        self.res_omega = float(res_omega)

def rhs_with_dtg(t, s_all, prm):
    pos, vel, theta = split_state_with_theta(s_all, N=3)

    # Energy deviation ed
    if prm.E0 is not None:
        E = total_energy_body(pack_state_bodies(pos, vel), prm.G, prm.masses, eps=prm.eps,
                              center_k=prm.center_k, center_GM=prm.center_GM, center_eps=prm.center_eps,
                              yukawa_k=prm.yukawa_k, yukawa_lambda=prm.yukawa_lambda, yukawa_repulsive=prm.yukawa_repulsive)
        ed = (E - prm.E0) / (abs(prm.E0) + 1e-15)
    else:
        ed = 0.0

    # DTG target (+ resonance)
    res_term = prm.res_amp * np.sin(prm.res_omega * t) if prm.res_amp != 0.0 and prm.res_omega != 0.0 else 0.0
    ed_eff = np.tanh(ed / max(1e-12, prm.ed_scale))
    target = prm.theta0 + prm.alpha_dtg*ed_eff - prm.beta_dtg*prm.lyap_const + res_term
    dtheta_raw = (target - theta) / max(prm.tau_theta, 1e-9)
    dtheta = np.clip(dtheta_raw, -prm.dtheta_max, prm.dtheta_max)

    theta_clamped = np.clip(theta, prm.theta_min, prm.theta_max)
    theta_dev = theta_clamped - prm.theta0
    nu_eff = np.clip(prm.nu0 + prm.k_nu*theta_dev + prm.k_nu_ed*ed, 0.0, prm.nu_max)

    k_ctrl_eff = prm.k_ctrl * (1.0 + prm.k_ctrl_e*abs(ed))
    if prm.soften_ctrl_when_clamped and (theta != theta_clamped):
        k_ctrl_eff *= 0.5

    # Close-approach gating with floor
    rmin_now = _rmin(pos)
    r_lo, r_hi = 0.03, 0.20
    r_mid = 0.5*(r_lo + r_hi)
    w = max(1e-12, (r_hi - r_lo)/6.0)
    g = 1.0/(1.0 + np.exp(-(rmin_now - r_mid)/w))  # 0..1
    k_ctrl_eff *= prm.gate_floor + (1.0 - prm.gate_floor) * (1.0 - g)

    # accelerations (full)
    acc = _acc_full(pos, vel, prm.G, prm.masses, prm.eps,
                    float(nu_eff), float(prm.turb_coeff), float(k_ctrl_eff), float(theta_dev),
                    float(prm.center_k), float(prm.center_GM), float(prm.center_eps),
                    bool(prm.ctrl_signed),
                    float(prm.yukawa_k), float(prm.yukawa_lambda), bool(prm.yukawa_repulsive))
    # apply planar spring (z-axis) after backend force
    if getattr(prm, "k_planar", 0.0) != 0.0:
        acc[2, :] -= prm.k_planar * pos[2, :]
    return np.concatenate([pack_state_bodies(vel, acc), np.array([dtheta])])

# ========================== Symplectic (K–D–K) ==========================
def dissipative_kick_inplace(pos, vel, dt, nu_eff, k_ctrl_eff, theta_dev, turb_coeff, ctrl_signed):
    # per-body damping factor: nu + k_ctrl*td  (turbulence acts as multiplicative +-)
    r2 = np.sum(pos*pos, axis=0)
    td = theta_dev if ctrl_signed else np.maximum(theta_dev, 0.0)
    damp = (nu_eff + k_ctrl_eff*td)
    # [muted] if turb_coeff != 0.0:
        # [muted] damp -= turb_coeff * np.sin(r2)  # 원래 +turb*vel 이므로, v' = v + dt*turb*vel ≈ (1 + dt*turb)*v
        # [muted] # 여기선 split에서 대칭 맞추기 위해 −부호로 넣고 양 끝에서 반씩 적용
    factor = (1.0 - 0.5*dt*damp)
    vel *= factor[None, :] if np.ndim(factor) else factor
def symplectic_step(pos, vel, dt, prm, th):
    # 현재 θ 편차(클램프 포함)
    theta_dev = (min(max(th, prm.theta_min), prm.theta_max) - prm.theta0)

    # half dissipative kick
    dissipative_kick_inplace(pos, vel, dt, prm.nu0, prm.k_ctrl, theta_dev,
                             prm.turb_coeff, prm.ctrl_signed)

    # conservative half-kick
    acc = _acc_cons(pos, vel, prm.G, prm.masses, prm.eps,
                    prm.center_k, prm.center_GM, prm.center_eps,
                    prm.yukawa_k, prm.yukawa_lambda, prm.yukawa_repulsive)
    vel += 0.5*dt*acc
    # drift
    pos += dt*vel
    # conservative half-kick
    acc2 = _acc_cons(pos, vel, prm.G, prm.masses, prm.eps,
                     prm.center_k, prm.center_GM, prm.center_eps,
                     prm.yukawa_k, prm.yukawa_lambda, prm.yukawa_repulsive)
    vel += 0.5*dt*acc2

    # 다시 한 번 최신 θ로 half dissipative kick (동일 th 사용)
    theta_dev2 = (min(max(th, prm.theta_min), prm.theta_max) - prm.theta0)
    dissipative_kick_inplace(pos, vel, dt, prm.nu0, prm.k_ctrl, theta_dev2,
                             prm.turb_coeff, prm.ctrl_signed)
    return pos, vel

    # conservative half-kick
    acc = _acc_cons(pos, vel, prm.G, prm.masses, prm.eps,
                    prm.center_k, prm.center_GM, prm.center_eps,
                    prm.yukawa_k, prm.yukawa_lambda, prm.yukawa_repulsive)
    # apply planar spring (z-axis) to conservative acc
    if getattr(prm, "k_planar", 0.0) != 0.0:
        acc[2, :] -= prm.k_planar * pos[2, :]
    vel += 0.5*dt*acc
    # drift
    pos += dt*vel
    # conservative half-kick
    acc2 = _acc_cons(pos, vel, prm.G, prm.masses, prm.eps,
                     prm.center_k, prm.center_GM, prm.center_eps,
                     prm.yukawa_k, prm.yukawa_lambda, prm.yukawa_repulsive)
    # apply planar spring (z-axis) to conservative acc2
    if getattr(prm, "k_planar", 0.0) != 0.0:
        acc2[2, :] -= prm.k_planar * pos[2, :]
    vel += 0.5*dt*acc2

    # half dissipative kick
    dissipative_kick_inplace(pos, vel, dt, prm.nu0, prm.k_ctrl, 0.0, prm.turb_coeff, prm.ctrl_signed)
    return pos, vel

def integrate_symplectic(t0, t1, y0, args, prm):
    # 간단한 KDK + theta는 ODE로 별도 적분(전진 오일러; dt가 작으면 충분)
    pos, vel, theta = split_state_with_theta(y0)
    T = np.arange(t0, t1 + 1e-12, args.dt)
    Y = np.empty((y0.size, T.size), dtype=float)
    Y[:, 0] = y0
    th = float(theta)
    for k in range(1, T.size):
        t_prev = T[k-1]
        # θ는 rhs_with_dtg의 dtheta를 사용해 업데이트(vel/pos는 심플렉틱으로)
        # target, ed 등 계산 위해 rhs 호출하되, 그 안의 acc는 쓰지 않고 dtheta만 이용
        dtheta = rhs_with_dtg(t_prev, np.concatenate([pack_state_bodies(pos, vel), np.array([th])]), prm)[-1]
        # 한 스텝
        pos, vel = symplectic_step(pos, vel, args.dt, prm, th)
        th = np.clip(th + args.dt * dtheta, prm.theta_min, prm.theta_max)
        Y[:, k] = np.concatenate([pack_state_bodies(pos, vel), np.array([th])])
    return T, Y

# ========================== Core integration (adaptive optional for DOP) ==========================
def integrate_with_optional_adaptive(rhs, t0, t1, y0, args, prm, events):
    if args.use_symplectic:
        return integrate_symplectic(t0, t1, y0, args, prm), dict(escaped=False, t_escape=None, collided=False, t_collision=None)

    cur_t = float(t0)
    cur_y = y0.copy()
    cur_max_step = args.dt
    T_list = [cur_t]
    Y_list = [cur_y]
    escaped = collided = False
    t_escape = t_collision = None

    while cur_t < t1 - 1e-12:
        t_next = min(cur_t + args.chunk, t1)
        sol = solve_ivp(lambda tt, ss: rhs(tt, ss, prm),
                        (cur_t, t_next), cur_y, t_eval=None,
                        events=events,
                        method="DOP853", rtol=1e-9, atol=1e-12, max_step=cur_max_step)
        if sol.t.size > 1:
            T_list.extend(sol.t[1:])
            Y_list.extend(sol.y[:,1:].T)
        cur_t = float(T_list[-1]); cur_y = Y_list[-1]

        if len(sol.t_events) >= 1 and len(sol.t_events[0]) > 0:
            escaped = True; t_escape = float(sol.t_events[0][0]); break
        if len(sol.t_events) >= 2 and len(sol.t_events[1]) > 0:
            collided = True; t_collision = float(sol.t_events[1][0]); break

        if args.adaptive_step:
            pos, _, _ = split_state_with_theta(cur_y)
            rmin = _rmin(pos)
            if rmin < args.adapt_r_trigger:
                cur_max_step = max(args.min_max_step, cur_max_step * args.adapt_factor)
            else:
                cur_max_step = min(args.dt, cur_max_step / max(1e-12, args.adapt_factor))

    T = np.array(T_list); Y = np.stack(Y_list, axis=1)
    return (T, Y), dict(escaped=escaped, t_escape=t_escape, collided=collided, t_collision=t_collision)

# ========================== Energies ==========================
def total_energy_body(s_body, G=1.0, masses=(1,1,1), eps=DEFAULT_EPS,
                      center_k=0.0, center_GM=0.0, center_eps=0.1,
                      yukawa_k=0.0, yukawa_lambda=0.5, yukawa_repulsive=True):
    pos, vel = unpack_state_bodies(s_body, N=3)
    masses = np.asarray(masses, float)
    # Kinetic
    K = 0.5 * np.sum(masses * np.sum(vel*vel, axis=0))
    # Pairwise potential: Newton + Yukawa + center
    dr, r2 = pairwise_dr(pos)
    r = np.sqrt(r2 + eps*eps)
    iu = np.triu_indices(len(masses), 1)
    U_pairs = -G * np.sum(masses[iu[0]] * masses[iu[1]] / r[iu])

    if yukawa_k != 0.0:
        sgn = +1.0 if yukawa_repulsive else -1.0
        U_y = sgn * yukawa_k * np.sum(np.exp(-yukawa_lambda * r[iu]) / r[iu] * (masses[iu[0]]*masses[iu[1]]))
    else:
        U_y = 0.0

    r2_self = np.sum(pos*pos, axis=0)  # (N,)
    U_center_h = 0.5 * np.sum(masses * center_k * r2_self)
    U_center_p = - np.sum(center_GM * masses / np.sqrt(r2_self + center_eps**2))
    return K + U_pairs + U_y + U_center_h + U_center_p

# ========================== Run simulation ==========================
def hold_true(x_bool, win):
    """
    x_bool: bool ndarray (시간축 1D)
    win   : 연속 유지해야 하는 샘플 수 (int >=1)
    """
    import numpy as np
    x = np.asarray(x_bool, dtype=bool).ravel()
    w = int(max(1, win))
    if x.size == 0: 
        return False
    cur = 0
    for b in x:
        cur = cur + 1 if b else 0
        if cur >= w:
            return True
    return False
def diag_planarity(z, tol=1e-3):
    """z 최대 절댓값이 tol보다 작으면 평면성 True."""
    import numpy as np
    z = np.asarray(z)
    zmax = float(np.max(np.abs(z))) if z.size else 0.0
    return bool(zmax < tol), zmax
def diag_fig8_similarity_phase(x, y, eps=1e-12):
    """세 궤적의 진행각 변화(unwrap) 표준화 후 페어 간 표준편차 합(낮을수록 유사)."""
    import numpy as np
    scores = []
    for i in range(3):
        dx = np.diff(x[i]); dy = np.diff(y[i])
        ang = np.arctan2(dy + 0.0, dx + eps)
        dang = np.unwrap(ang)
        std = np.std(dang) + eps
        z = (dang - dang.mean()) / std
        scores.append(z)
    def pair_score(a, b):
        n = min(len(a), len(b))
        a = a[:n]; b = b[:n]
        return float(np.std(a - b))
    return pair_score(scores[0], scores[1]) + pair_score(scores[1], scores[2]) + pair_score(scores[0], scores[2])

if getattr(args, "compare", False):
    results = []
    scan_list = [args.nu0] + [nu for nu in getattr(args, "nu_scan", []) if nu != args.nu0]
    for nu in (scan_list or [0.003]):
        b_args = argparse.Namespace(**vars(args))
        b_args.dtg = 0
        b_args.nu0 = nu
        b_args.out = os.path.join(args.out, f"baseline_nu{nu}")
        meta_b, csv_b, lam_b, drift_b, theta_b, planar_b, fig8_b = run_simulation(b_args)

        d_args = argparse.Namespace(**vars(args))
        d_args.dtg = 1
        d_args.nu0 = nu
        d_args.out = os.path.join(args.out, f"dtg_nu{nu}")
        meta_d, csv_d, lam_d, drift_d, theta_d, planar_d, fig8_d = run_simulation(d_args)
else:
    meta, csv_diag, lam, drift, theta_hist, planar, fig8_phase = run_simulation(args)


args = ap.parse_args()

if getattr(args, "compare", False):
    results = []
    scan_list = [args.nu0] + [nu for nu in getattr(args, "nu_scan", []) if nu != args.nu0]
    for nu in (scan_list or [0.003]):
        b_args = argparse.Namespace(**vars(args))
        b_args.dtg = 0
        b_args.nu0 = nu
        b_args.out = os.path.join(args.out, f"baseline_nu{nu}")
        meta_b, csv_b, lam_b, drift_b, theta_b, planar_b, fig8_b = run_simulation(b_args)

        d_args = argparse.Namespace(**vars(args))
        d_args.dtg = 1
        d_args.nu0 = nu
        d_args.out = os.path.join(args.out, f"dtg_nu{nu}")
        meta_d, csv_d, lam_d, drift_d, theta_d, planar_d, fig8_d = run_simulation(d_args)
else:
    meta, csv_diag, lam, drift, theta_hist, planar, fig8_phase = run_simulation(args)
