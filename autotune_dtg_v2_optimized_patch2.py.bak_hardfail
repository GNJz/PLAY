#!/usr/bin/env python3
"""
autotune_dtg_v2_optimized_patch2.py
- DTG 컨트롤러 파라미터 자동 탐색/검증 오케스트레이터 (최적화+호환성 패치)
- macOS/Windows에서 multiprocessing 안정화를 위해 'spawn' 컨텍스트 사용
- 과도한 내부 스레딩 방지(OMP/MKL/BLAS) 환경변수 선설정
"""

from __future__ import annotations

import os
# ---- Limit BLAS/OMP threads EARLY (must be before numpy/scipy import in child) ----
os.environ.setdefault("OMP_NUM_THREADS", "1")
os.environ.setdefault("MKL_NUM_THREADS", "1")
os.environ.setdefault("OPENBLAS_NUM_THREADS", "1")
os.environ.setdefault("VECLIB_MAXIMUM_THREADS", "1")
os.environ.setdefault("NUMEXPR_NUM_THREADS", "1")

import argparse
import csv
import json
import random
import re
import subprocess
import sys
import time
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
from multiprocessing import get_context, cpu_count

# =========================== 유틸 ===========================

def _now_tag() -> str:
    return time.strftime("%Y%m%d-%H%M%S")

def ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)

def read_params_from_meta(meta_dir: Path) -> Dict[str, Any]:
    out: Dict[str, Any] = {}
    if not meta_dir.exists():
        return out
    for jf in sorted(meta_dir.glob("*.json")):
        try:
            with open(jf, "r", encoding="utf-8") as f:
                data = json.load(f)
            if isinstance(data, dict):
                out.update(data.get("args", {}))
                for k in ("beta_dtg","tau_theta","theta_min","theta_max",
                          "k_ctrl","k_ctrl_e","k_nu","k_nu_ed"):
                    if k in data:
                        out[k] = data[k]
                es = data.get("end_state", {})
                if isinstance(es, dict) and "fig8_phase" in es:
                    out["fig8_phase"] = es["fig8_phase"]
        except Exception:
            pass
    return out

def safe_read_csv(path: Path, usecols: Optional[List[str]] = None) -> Dict[str, List[float]]:
    out: Dict[str, List[float]] = {}
    try:
        with open(path, "r", newline="", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            cols = usecols or (reader.fieldnames or [])
            for c in cols:
                out[c] = []
            for row in reader:
                for c in cols:
                    try:
                        out[c].append(float(row[c]))
                    except Exception:
                        pass
    except Exception:
        pass
    return out

def compute_theta_rate(t: List[float], theta: List[float]) -> float:
    if len(t) < 2 or len(theta) < 2:
        return 0.0
    dt_accum = 0.0
    dth_accum = 0.0
    m = min(len(t), len(theta))
    for i in range(1, m):
        dt = t[i] - t[i-1]
        if dt <= 0:
            continue
        dth_accum += abs(theta[i] - theta[i-1])
        dt_accum += dt
    return (dth_accum / dt_accum) if dt_accum > 0 else 0.0

# =========================== 스코어 ===========================

@dataclass
class ScoreWeights:
    w_drift: float = 100.0
    w_theta: float = 1.0
    w_fig8: float = 1.0
    fig8_target: float = 1.0
    drift_floor: float = 0.01
    hard_fail: float = 0.10
    penalty_escape: float = 200.0
    penalty_binary: float = 50.0

def score_run(
    drift_max: float,
    theta_rate: float,
    fig8_phase: float,
    W: ScoreWeights,
    *,
    t_escape: float = float("nan"),
    ran_tmax: Optional[float] = None,
    binary: int = 0
) -> float:
    if drift_max != drift_max:
        return float("inf")
    if drift_max > W.hard_fail:
        return 1e9 + drift_max

    cost = W.w_drift * max(drift_max, W.drift_floor)
    if fig8_phase == fig8_phase:
        cost += W.w_fig8 * abs(fig8_phase - W.fig8_target)
    cost += -W.w_theta * theta_rate

    if binary:
        cost += W.penalty_binary
    if (t_escape == t_escape) and (ran_tmax is not None) and ran_tmax > 0:
        frac = t_escape / ran_tmax
        if frac < 0.9:
            cost += W.penalty_escape * (0.9 - frac)
    return float(cost)

# =========================== 실행기 ===========================

@dataclass
class Param:
    alpha_dtg: float = 0.6
    beta_dtg: float = 0.6
    tau_theta: float = 1.0
    dtheta_max: float = 0.10
    theta_min: float = 0.95
    theta_max: float = 2.0
    k_ctrl: float = 0.20
    k_ctrl_e: float = 0.50
    k_nu: float = 0.0
    k_nu_ed: float = 0.25
    nu0: float = 0.002
    nu_max: float = 0.2
    dt: float = 0.002
    tmax: float = 20.0
    ic: str = "exp2"
    alpha: float = 1.0
    dtg: int = 1
    no_plots: bool = True
    lyap_light: bool = False
    adaptive_step: bool = False
    adapt_r_trigger: float = 0.02
    adapt_factor: float = 0.3
    min_max_step: float = 2e-4

    def as_cmd(self, sim_path: str, outdir: Path) -> List[str]:
        cmd = [
            sys.executable, sim_path,
            "--ic", self.ic, "--alpha", str(self.alpha),
            "--tmax", str(self.tmax), "--dt", str(self.dt),
            "--dtg", str(self.dtg),
            "--alpha_dtg", str(self.alpha_dtg),
            "--beta_dtg", str(self.beta_dtg),
            "--tau_theta", str(self.tau_theta),
            "--dtheta_max", str(self.dtheta_max),
            "--theta_min", str(self.theta_min),
            "--theta_max", str(self.theta_max),
            "--k_ctrl", str(self.k_ctrl),
            "--k_ctrl_e", str(self.k_ctrl_e),
            "--k_nu", str(self.k_nu),
            "--k_nu_ed", str(self.k_nu_ed),
            "--nu0", str(self.nu0),
            "--nu_max", str(self.nu_max),
            "--out", str(outdir),
        ]
        if self.no_plots:
            cmd.append("--no_plots")
        if self.lyap_light:
            cmd.append("--lyap_light")
        if self.adaptive_step:
            cmd += [
                "--adaptive_step",
                "--adapt_r_trigger", str(self.adapt_r_trigger),
                "--adapt_factor", str(self.adapt_factor),
                "--min_max_step", str(self.min_max_step),
            ]
        return cmd


def _parse_stdout(run_dir: Path, out: Dict[str, Any]) -> None:
    s = run_dir / "stdout.txt"
    if not s.exists():
        return
    try:
        txt = s.read_text(encoding="utf-8", errors="ignore")

        # escape 시점
        m = re.search(r"\[event\]\s*escape at t≈([0-9.]+)", txt)
        if m:
            try:
                out["t_escape"] = float(m.group(1))
            except Exception:
                pass

        # binary formation detected 여부
        if "binary formation detected" in txt:
            out["binary"] = 1

    except Exception:
        pass
def run_and_evaluate(sim_path: str, out_root: Path, p: Param, W: ScoreWeights, phase: str) -> Dict[str, Any]:
    """병렬 실행을 위한 통합 함수: run_once + evaluate_run + score + row 생성"""
    # 유니크 폴더: timestamp + pid + 랜덤 4자리
    tag = f"{_now_tag()}_{os.getpid()}_{random.randint(1000,9999)}"
    run_name = (
        f"auto_beta{p.beta_dtg:.3f}_tau{p.tau_theta:.3f}_d{p.dtheta_max:.3f}"
        f"_thmin{p.theta_min:.3f}_kc{p.k_ctrl:.3f}_ke{p.k_ctrl_e:.3f}_knued{p.k_nu_ed:.3f}_{tag}"
    )
    outdir = out_root / run_name
    ensure_dir(outdir)
    cmd = p.as_cmd(sim_path, outdir)

    status = "ok"
    try:
        res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, check=False)
        (outdir / "stdout.txt").write_text(res.stdout, encoding="utf-8")
        if res.returncode != 0:
            status = f"retcode={res.returncode}"
    except Exception as e:
        status = f"error:{e}"

    # 평가
    met: Dict[str, Any] = {
        "run_dir": str(outdir),
        "drift_max": float("nan"),
        "theta_rate": float("nan"),
        "fig8_phase": float("nan"),
        "status": "no_diag",
        "t_escape": float("nan"),
        "binary": 0,
    }

    data_dir = outdir / "data"
    meta_dir = outdir / "meta"
    diag_candidates = sorted(data_dir.glob("diagnostics_*.csv"))
    if diag_candidates:
        dd = safe_read_csv(diag_candidates[0], usecols=["t", "drift", "theta"])
        t = dd.get("t", [])
        drift = dd.get("drift", [])
        theta = dd.get("theta", [])
        if drift:
            met["drift_max"] = float(max(abs(x) for x in drift))
        met["theta_rate"] = compute_theta_rate(t, theta)
        met["status"] = "ok"

    meta = read_params_from_meta(meta_dir)
    if "fig8_phase" in meta:
        try:
            met["fig8_phase"] = float(meta["fig8_phase"])
        except Exception:
            pass
    _parse_stdout(outdir, met)

    cost = score_run(
        met.get("drift_max", float("nan")),
        met.get("theta_rate", float("nan")),
        met.get("fig8_phase", float("nan")),
        W,
        t_escape=met.get("t_escape", float("nan")),
        ran_tmax=p.tmax,
        binary=int(met.get("binary", 0) or 0)
    )

    row = {
        "phase": phase,
        "status": status,
        "cost": cost if status == "ok" else float("inf"),
        "drift_max": met.get("drift_max"),
        "theta_rate": met.get("theta_rate"),
        "fig8_phase": met.get("fig8_phase"),
        "t_escape": met.get("t_escape"),
        "binary": met.get("binary"),
        **asdict(p),
        "run_dir": str(outdir),
    }
    return row

# =========================== 고정 CSV 스키마 ===========================

PARAM_KEYS = [
    "alpha_dtg","beta_dtg","tau_theta","dtheta_max","theta_min","theta_max",
    "k_ctrl","k_ctrl_e","k_nu","k_nu_ed",
    "nu0","nu_max","dt","tmax","ic","alpha","dtg",
    "no_plots","lyap_light","adaptive_step","adapt_r_trigger","adapt_factor","min_max_step",
]
FIELDNAMES = [
    "phase","status","cost","drift_max","theta_rate","fig8_phase","t_escape","binary",
    *PARAM_KEYS, "run_dir"
]

def _row_to_fixed_fields(row: Dict[str, Any]) -> Dict[str, Any]:
    out: Dict[str, Any] = {}
    for k in FIELDNAMES:
        out[k] = row.get(k, "")
    return out

def append_log(log_csv: Path, row: Dict[str, Any]) -> None:
    existed = log_csv.exists()
    with open(log_csv, "a", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=FIELDNAMES, extrasaction="ignore")
        if not existed:
            w.writeheader()
        w.writerow(_row_to_fixed_fields(row))

def load_log(log_csv: Path) -> List[Dict[str, Any]]:
    if not log_csv.exists():
        return []
    out: List[Dict[str, Any]] = []
    with open(log_csv, "r", encoding="utf-8") as f:
        r = csv.DictReader(f)
        for row in r:
            if None in row:
                row.pop(None, None)
            out.append(row)
    return out

def _safe_float(x: Any, default: float = float("inf")) -> float:
    try:
        return float(x)
    except Exception:
        try:
            s = re.sub(r"[^0-9eE+.\-]", "", str(x))
            return float(s) if s else default
        except Exception:
            return default

# =========================== 탐색 공간 ===========================

@dataclass
class Space:
    beta_dtg: Tuple[float,float] = (0.30, 0.80)
    tau_theta: Tuple[float,float] = (0.60, 1.40)
    dtheta_max: Tuple[float,float] = (0.08, 0.16)
    theta_min: Tuple[float,float] = (0.90, 0.98)
    k_ctrl: Tuple[float,float] = (0.15, 0.30)
    k_ctrl_e: Tuple[float,float] = (0.30, 0.70)
    k_nu_ed: Tuple[float,float] = (0.15, 0.30)

    def sample_uniform(self, rng: random.Random) -> Dict[str,float]:
        U = rng.uniform
        return {
            "beta_dtg": U(*self.beta_dtg),
            "tau_theta": U(*self.tau_theta),
            "dtheta_max": U(*self.dtheta_max),
            "theta_min": U(*self.theta_min),
            "k_ctrl": U(*self.k_ctrl),
            "k_ctrl_e": U(*self.k_ctrl_e),
            "k_nu_ed": U(*self.k_nu_ed),
        }

    def mutate(self, base: Dict[str,float], rng: random.Random, sigma_frac: float = 0.25) -> Dict[str,float]:
        out = {}
        for k in base.keys():
            lo, hi = getattr(self, k)
            span = hi - lo
            sigma = sigma_frac * span
            val = rng.gauss(base[k], sigma)
            out[k] = max(lo, min(hi, val))
        return out

# =========================== 액션 ===========================

def _pool_map_starmap(num_processes: int, func, param_tuples: List[tuple]):
    """Spawn-safe pool with graceful close/terminate."""
    ctx = get_context("spawn")
    pool = ctx.Pool(processes=num_processes)
    try:
        results = pool.starmap(func, param_tuples)
    finally:
        pool.close()
        pool.join()
    return results

def act_explore(args):
    rng = random.Random(args.seed)
    W = ScoreWeights(
        w_drift=args.w_drift, w_theta=args.w_theta, w_fig8=args.w_fig8,
        fig8_target=args.fig8_target, drift_floor=args.drift_floor, hard_fail=args.hard_fail,
        penalty_escape=args.penalty_escape, penalty_binary=args.penalty_binary
    )
    space = Space()
    out_root = Path(args.out_root); ensure_dir(out_root)
    log_csv = Path(args.log_csv)
    num_processes = max(1, args.num_processes or cpu_count())

    evaluated: List[Dict[str, Any]] = []

    # 초기 균등 샘플 (병렬 실행)
    params_list = []
    for _ in range(args.n_init):
        s = space.sample_uniform(rng)
        p = Param(
            beta_dtg=s["beta_dtg"], tau_theta=s["tau_theta"], dtheta_max=s["dtheta_max"],
            theta_min=s["theta_min"], k_ctrl=s["k_ctrl"], k_ctrl_e=s["k_ctrl_e"],
            k_nu=0.0, k_nu_ed=s["k_nu_ed"], tmax=args.tmax_short,
            no_plots=True, lyap_light=True, adaptive_step=True
        )
        params_list.append((args.sim_path, out_root, p, W, "explore"))

    results = _pool_map_starmap(num_processes, run_and_evaluate, params_list)
    for idx, row in enumerate(results):
        append_log(log_csv, row)
        evaluated.append(row)
        print(f"[explore {idx+1}/{args.n_init}] cost={row['cost']:.4g} drift={row['drift_max']:.3g} "
              f"theta_rate={row['theta_rate']:.3g} fig8={row['fig8_phase']:.3g} → {Path(row['run_dir']).name}")

    # 변이 반복 (병렬 실행)
    sigma_frac = args.sigma_frac
    for it in range(args.iters):
        evaluated.sort(key=lambda r: _safe_float(r["cost"]))
        parents = evaluated[:max(3, args.n_init // 4)]
        n_children = max(1, args.n_init // 2)
        params_list = []
        for _ in range(n_children):
            base = random.choice(parents)
            seed = {
                "beta_dtg": float(base["beta_dtg"]),
                "tau_theta": float(base["tau_theta"]),
                "dtheta_max": float(base["dtheta_max"]),
                "theta_min": float(base["theta_min"]),
                "k_ctrl": float(base["k_ctrl"]),
                "k_ctrl_e": float(base["k_ctrl_e"]),
                "k_nu_ed": float(base["k_nu_ed"]),
            }
            s = space.mutate(seed, rng, sigma_frac=sigma_frac)
            p = Param(
                beta_dtg=s["beta_dtg"], tau_theta=s["tau_theta"], dtheta_max=s["dtheta_max"],
                theta_min=s["theta_min"], k_ctrl=s["k_ctrl"], k_ctrl_e=s["k_ctrl_e"],
                k_nu=0.0, k_nu_ed=s["k_nu_ed"], tmax=args.tmax_short,
                no_plots=True, lyap_light=True, adaptive_step=True
            )
            params_list.append((args.sim_path, out_root, p, W, f"explore@{it+1}"))

        results = _pool_map_starmap(num_processes, run_and_evaluate, params_list)
        for idx, row in enumerate(results):
            append_log(log_csv, row)
            evaluated.append(row)
            print(f"[mut {it+1}:{idx+1}/{n_children}] cost={row['cost']:.4g} drift={row['drift_max']:.3g} "
                  f"theta_rate={row['theta_rate']:.3g} fig8={row['fig8_phase']:.3g} → {Path(row['run_dir']).name}")
        sigma_frac *= 0.8

    # 리더보드
    evaluated.sort(key=lambda r: _safe_float(r["cost"]))
    top_path = Path(args.top_csv)
    with open(top_path, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=FIELDNAMES)
        w.writeheader()
        for r in evaluated[:args.top_keep]:
            w.writerow(_row_to_fixed_fields(r))
    print(f"\n[done] wrote leaderboard: {top_path}")

def act_exploit(args):
    rows = load_log(Path(args.log_csv))
    if not rows:
        print("No log rows. Run explore first.")
        return
    rows.sort(key=lambda r: _safe_float(r.get("cost", float("inf"))))
    top = rows[:args.top_k]

    W = ScoreWeights(
        w_drift=args.w_drift, w_theta=args.w_theta, w_fig8=args.w_fig8,
        fig8_target=args.fig8_target, drift_floor=args.drift_floor, hard_fail=args.hard_fail,
        penalty_escape=args.penalty_escape, penalty_binary=args.penalty_binary
    )

    out_root = Path(args.out_root); ensure_dir(out_root)
    num_processes = max(1, args.num_processes or cpu_count())

    params_list = []
    for r in top:
        p = Param(
            beta_dtg=float(r["beta_dtg"]),
            tau_theta=float(r["tau_theta"]),
            dtheta_max=float(r["dtheta_max"]),
            theta_min=float(r["theta_min"]),
            k_ctrl=float(r["k_ctrl"]),
            k_ctrl_e=float(r["k_ctrl_e"]),
            k_nu=0.0,
            k_nu_ed=float(r["k_nu_ed"]),
            tmax=args.tmax_long,
            no_plots=False, lyap_light=True, adaptive_step=True
        )
        params_list.append((args.sim_path, out_root, p, W, "exploit"))

    results = _pool_map_starmap(num_processes, run_and_evaluate, params_list)
    for idx, row in enumerate(results):
        append_log(Path(args.log_csv), row)
        print(f"[exploit {idx+1}/{len(top)}] cost={row['cost']:.4g} drift={row['drift_max']:.3g} "
              f"theta_rate={row['theta_rate']:.3g} fig8={row['fig8_phase']:.3g} → {Path(row['run_dir']).name}")

def act_summarize(args):
    rows = load_log(Path(args.log_csv))
    if not rows:
        print("No log yet.")
        return
    rows.sort(key=lambda r: _safe_float(r.get("cost", float("inf"))))

    out = Path(args.sorted_csv)
    with open(out, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=FIELDNAMES)
        w.writeheader()
        for r in rows:
            w.writerow(_row_to_fixed_fields(r))

    k = min(args.top_k, len(rows))
    print(f"Top {k} (lower cost is better):")
    for i in range(k):
        r = rows[i]
        def gf(key, d=float("nan")): return _safe_float(r.get(key, d), d)
        print(
            f"{i+1:2d}. cost={gf('cost'):.4g} drift={gf('drift_max'):.3g} "
            f"theta={gf('theta_rate'):.3g} fig8={gf('fig8_phase'):.3g} "
            f"beta={gf('beta_dtg'):.3f} tau={gf('tau_theta'):.3f} dth={gf('dtheta_max'):.3f} "
            f"thmin={gf('theta_min'):.3f} kc={gf('k_ctrl'):.3f} ke={gf('k_ctrl_e'):.3f} "
            f"knued={gf('k_nu_ed'):.3f} esc={gf('t_escape'):.2f} bin={int(gf('binary', 0))}"
        )
    print(f"\n[done] wrote sorted log: {out}")

# =========================== CLI ===========================

def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(description="Auto-tune DTG controller parameters (v2 optimized, spawn-safe)")
    p.add_argument("--sim_path", default="three_body_3d_ns_dtg_v3_3_stable.py",
                   help="시뮬레이터 경로")
    p.add_argument("--out_root", default="runs/auto", help="출력 루트")
    p.add_argument("--log_csv", default="autotune_log.csv", help="누적 로그 CSV")
    p.add_argument("--top_csv", default="autotune_top.csv", help="리더보드 CSV")
    p.add_argument("--sorted_csv", default="autotune_log_sorted.csv", help="정렬 전체 로그")
    p.add_argument("--num_processes", type=int, default=None, help="병렬 프로세스 수 (기본: CPU 코어 수)")

    sub = p.add_subparsers(dest="cmd", required=True)

    ex = sub.add_parser("explore", help="초기 탐색+지역 변이")
    ex.add_argument("--n_init", type=int, default=16)
    ex.add_argument("--iters", type=int, default=3)
    ex.add_argument("--sigma_frac", type=float, default=0.25)
    ex.add_argument("--seed", type=int, default=42)
    ex.add_argument("--tmax_short", type=float, default=20.0)
    ex.add_argument("--top_keep", type=int, default=50)
    ex.add_argument("--w_drift", type=float, default=100.0)
    ex.add_argument("--w_theta", type=float, default=1.0)
    ex.add_argument("--w_fig8", type=float, default=1.0)
    ex.add_argument("--fig8_target", type=float, default=1.0)
    ex.add_argument("--drift_floor", type=float, default=0.01)
    ex.add_argument("--hard_fail", type=float, default=0.10)
    ex.add_argument("--penalty_escape", type=float, default=200.0)
    ex.add_argument("--penalty_binary", type=float, default=50.0)
    ex.set_defaults(func=act_explore)

    ep = sub.add_parser("exploit", help="상위 후보 장주행 검증")
    ep.add_argument("--top_k", type=int, default=3)
    ep.add_argument("--tmax_long", type=float, default=60.0)
    ep.add_argument("--w_drift", type=float, default=100.0)
    ep.add_argument("--w_theta", type=float, default=1.0)
    ep.add_argument("--w_fig8", type=float, default=1.0)
    ep.add_argument("--fig8_target", type=float, default=1.0)
    ep.add_argument("--drift_floor", type=float, default=0.01)
    ep.add_argument("--hard_fail", type=float, default=0.10)
    ep.add_argument("--penalty_escape", type=float, default=200.0)
    ep.add_argument("--penalty_binary", type=float, default=50.0)
    ep.set_defaults(func=act_exploit)

    sm = sub.add_parser("summarize", help="리더보드/정렬 로그 출력")
    sm.add_argument("--top_k", type=int, default=10)
    sm.set_defaults(func=act_summarize)
    return p

def main(argv=None):
    parser = build_parser()
    args = parser.parse_args(argv)
    args.func(args)

if __name__ == "__main__":
    main()
