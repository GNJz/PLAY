#!/usr/bin/env python3
# three_body_3d_ns_dtg_v3_5_full.py
# 3D Three-body + drag(ν) + (opt) turbulence + DTG + central anchor potential
# - Hot kernels: Numba -> NumPy 폴백, (옵션) C++/pybind11 커널 우선 사용
# - DTG: signed/rectified, theta_init, energy/lyap 피드백, 공명항(res_amp,res_omega)
# - Integrators: DOP853(기본), --use_symplectic (K-D-K Verlet + dissipation split)
# - Potentials: Newton + Central(Harmonic + Plummer) + (옵션) Yukawa(repulsive/screened)
# - Outputs: CSV(main/diagnostics), figures, meta.json, 판정(Partial/Success)

#!/usr/bin/env python3
# three_body_3d_ns_dtg_v3_5_full.py

import argparse, os, json, time, sys, platform
import numpy as np
# [ADD] center-of-mass recentering helper
def com_recenter(state, mode="momentum"):
    """
    state: shape (3, 6): [[x,y,z,vx,vy,vz], ...], equal masses assumed
    mode : 'momentum' -> zero COM velocity only
           'full'     -> zero COM position & velocity
    """
    import numpy as np
    r = state[:, :3].copy()
    v = state[:, 3:].copy()
    m = np.ones(3)
    M = m.sum()
    Rcom = (m[:, None] * r).sum(axis=0) / M
    Vcom = (m[:, None] * v).sum(axis=0) / M
    if mode in ("momentum", "full"):
        v -= Vcom
    if mode == "full":
        r -= Rcom
    state[:, :3] = r
    state[:, 3:] = v
    return state
import pandas as pd
from scipy.integrate import solve_ivp

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

DEFAULT_EPS = 1e-8

# --- runtime backend flags (injected) ---
try:
    HAVE_NUMBA   # may already exist
except NameError:
    HAVE_NUMBA = False
try:
    CEXT
except NameError:
    CEXT = None  # external C/C++ ext fallback disabled by default
BACKEND = "Numba" if HAVE_NUMBA else "NumPy"


# 외부 C 확장(있으면 사용, 없으면 None)
CEXT = None

# ========== optional Numba ==========
HAVE_NUMBA = False
try:
    from numba import njit
    HAVE_NUMBA = True
except Exception:
    def njit(*args, **kwargs):
        # no-op decorator when numba not available
        def deco(f): 
            return f
        return deco
# ====================================

# ========================== Utilities ==========================
# ========================== Utilities ==========================
def unpack_state_bodies(s, N=3):
    s = np.asarray(s, float).reshape(-1)
    if s.size != 6*N:
        raise ValueError(f"state length must be 6N (= {6*N}), got {s.size}")
    pos = s[:3*N].reshape(3, N, order="F")
    vel = s[3*N:6*N].reshape(3, N, order="F")
    return pos, vel

def pack_state_bodies(pos, vel):
    if pos.shape != vel.shape or pos.shape[0] != 3:
        raise ValueError("pos/vel must be (3,N)")
    N = pos.shape[1]
    return np.concatenate([pos.reshape(3*N, order="F"),
                           vel.reshape(3*N, order="F")])

def split_state_with_theta(s, N=3):
    s = np.asarray(s, float).reshape(-1)
    body, theta = s[:-1], float(s[-1])
    pos, vel = unpack_state_bodies(body, N=N)
    return pos, vel, theta

def pairwise_dr(pos):
    dr = pos[:, None, :] - pos[:, :, None]    # (3,N,N)
    r2 = np.sum(dr*dr, axis=0)                # (N,N)
    return dr, r2

# ===== central anchor (origin) =====
def center_force_np(pos, masses, center_k=0.0, center_GM=0.0, center_eps=0.1):
    """F_center = -m_i*center_k*r_i  - (center_GM*m_i)*r_i/(|r_i|^2+eps^2)^{3/2}
       center_GM = G*M_center (already multiplied)"""
    if (center_k == 0.0) and (center_GM == 0.0):
        return 0.0
    r2 = np.sum(pos*pos, axis=0)  # (N,)
    F_h = - (center_k * masses)[None, :] * pos
    invr3 = (r2 + center_eps**2) ** (-1.5)
    F_p = - (center_GM * masses)[None, :] * (pos * invr3[None, :])
    return F_h + F_p

# ===== Yukawa force (repulsive/screened) =====
def yukawa_pair_force_np(dr, r, m_j, k, lam, repulsive=True):
    # Potential: V = sgn * k * exp(-lam r) / r  (sgn=+1: repulsive)
    # |F| = -dV/dr = sgn * k * exp(-lam r) * (1/r^2 + lam/r)
    if k == 0.0:
        return 0.0
    sgn = +1.0 if repulsive else -1.0
    fac = sgn * k * np.exp(-lam * r) * (1.0/(r*r) + lam/r) / r  # divide by r for unit vector multiply
    return (fac * m_j) * dr  # scale by mass like gravity

def accelerations_np_full(pos, vel, G, masses, eps=DEFAULT_EPS,
                          nu_eff=0.0, turb_coeff=0.0, k_ctrl_eff=0.0, theta_dev=0.0,
                          center_k=0.0, center_GM=0.0, center_eps=0.1,
                          ctrl_signed=False, yukawa_k=0.0, yukawa_lambda=0.5, yukawa_repulsive=True):
    """전체 힘(중력+점성+제어+난류+앵커+Yukawa)"""
    N = pos.shape[1]
    dr, r2 = pairwise_dr(pos)
    r2 = r2 + eps*eps
    mask = ~np.eye(N, dtype=bool)
    inv_r3 = np.where(mask, r2**-1.5, 0.0)
    w = masses[None, :] * inv_r3
    grav = G * np.einsum('kij,ij->ki', dr, w)

    # pairwise Yukawa
    if yukawa_k != 0.0:
        F_yuk = np.zeros_like(pos)
        for i in range(N):
            for j in range(N):
                if i == j: continue
                rij = np.sqrt(r2[i,j])
                if rij > 0:
                    F_yuk[:, i] += yukawa_pair_force_np(dr[:, i, j], rij, masses[j], yukawa_k, yukawa_lambda, yukawa_repulsive)
    else:
        F_yuk = 0.0

    visc = -nu_eff * vel
    if ctrl_signed:
        ctrl = -k_ctrl_eff * (theta_dev) * vel
    else:
        theta_dev_pos = np.maximum(theta_dev, 0.0)
        ctrl = -k_ctrl_eff * theta_dev_pos * vel
    turb = turb_coeff * np.sin(np.sum(pos*pos, axis=0))[None, :] * vel if turb_coeff else 0.0

    F_center = center_force_np(pos, masses, center_k=center_k, center_GM=center_GM, center_eps=center_eps)
    return grav + F_yuk + visc + turb + ctrl + F_center

def accelerations_np_conservative(pos, vel, G, masses, eps=DEFAULT_EPS,
                                  center_k=0.0, center_GM=0.0, center_eps=0.1,
                                  yukawa_k=0.0, yukawa_lambda=0.5, yukawa_repulsive=True):
    """보수계 힘(점성/제어/난류 제외) — 심플렉틱용"""
    N = pos.shape[1]
    dr, r2 = pairwise_dr(pos)
    r2 = r2 + eps*eps
    mask = ~np.eye(N, dtype=bool)
    inv_r3 = np.where(mask, r2**-1.5, 0.0)
    w = masses[None, :] * inv_r3
    grav = G * np.einsum('kij,ij->ki', dr, w)
    if yukawa_k != 0.0:
        F_yuk = np.zeros_like(pos)
        for i in range(N):
            for j in range(N):
                if i == j: continue
                rij = np.sqrt(r2[i,j])
                if rij > 0:
                    F_yuk[:, i] += yukawa_pair_force_np(dr[:, i, j], rij, masses[j], yukawa_k, yukawa_lambda, yukawa_repulsive)
    else:
        F_yuk = 0.0
    F_center = center_force_np(pos, masses, center_k=center_k, center_GM=center_GM, center_eps=center_eps)
    return grav + F_yuk + F_center

# ===== Numba hot kernels =====
@njit(cache=True, fastmath=True)
def min_pair_distance_numba(pos):  # pos: (3,N)
    N = pos.shape[1]
    m = 1.0e300
    for i in range(N):
        xi = pos[0,i]; yi = pos[1,i]; zi = pos[2,i]
        for j in range(i+1, N):
            dx = xi - pos[0,j]
            dy = yi - pos[1,j]
            dz = zi - pos[2,j]
            d2 = dx*dx + dy*dy + dz*dz
            if d2 < m: m = d2
    return np.sqrt(m)

@njit(cache=True, fastmath=True)
def accelerations_numba_full(pos, vel, G, masses, eps,
                             nu_eff, turb_coeff, k_ctrl_eff, theta_dev,
                             center_k, center_GM, center_eps, ctrl_signed,
                             yukawa_k, yukawa_lambda, yukawa_repulsive):
    N = pos.shape[1]
    acc = np.zeros_like(pos)
    for i in range(N):
        xi = pos[0,i]; yi = pos[1,i]; zi = pos[2,i]
        ax = 0.0; ay = 0.0; az = 0.0

        # pairwise gravity + Yukawa
        for j in range(N):
            if i == j: 
                continue
            dx = xi - pos[0,j]
            dy = yi - pos[1,j]
            dz = zi - pos[2,j]
            r2 = dx*dx + dy*dy + dz*dz + eps*eps
            r = np.sqrt(r2)
            invr3 = 1.0 / (r2 * r)
            s = -G * masses[j] * invr3
            ax += s*dx; ay += s*dy; az += s*dz

            if yukawa_k != 0.0:
                sgn = 1.0 if yukawa_repulsive else -1.0
                fac = sgn * yukawa_k * np.exp(-yukawa_lambda * r) * (1.0/(r*r) + yukawa_lambda/r) / r
                fac *= masses[j]
                ax += fac*dx; ay += fac*dy; az += fac*dz

        # viscous + control
        td = theta_dev if ctrl_signed else (theta_dev if theta_dev > 0.0 else 0.0)
        damp = nu_eff + k_ctrl_eff*td
        ax += -damp * vel[0,i]
        ay += -damp * vel[1,i]
        az += -damp * vel[2,i]

        # turbulence (optional)
        if turb_coeff != 0.0:
            s2 = xi*xi + yi*yi + zi*zi
            turb = turb_coeff * np.sin(s2)
            ax += turb*vel[0,i]; ay += turb*vel[1,i]; az += turb*vel[2,i]

        # center force (harmonic + Plummer)
        r2c = xi*xi + yi*yi + zi*zi
        ax += -(center_k * masses[i]) * xi
        ay += -(center_k * masses[i]) * yi
        az += -(center_k * masses[i]) * zi
        invr3c = 1.0 / ((r2c + center_eps*center_eps)**1.5)
        sC = -(center_GM * masses[i]) * invr3c
        ax += sC*xi; ay += sC*yi; az += sC*zi

        acc[0,i] = ax; acc[1,i] = ay; acc[2,i] = az
    return acc

@njit(cache=True, fastmath=True)
def accelerations_numba_conservative(pos, vel, G, masses, eps,
                                     center_k, center_GM, center_eps,
                                     yukawa_k, yukawa_lambda, yukawa_repulsive):
    N = pos.shape[1]
    acc = np.zeros_like(pos)
    for i in range(N):
        xi = pos[0,i]; yi = pos[1,i]; zi = pos[2,i]
        ax = 0.0; ay = 0.0; az = 0.0
        for j in range(N):
            if i == j: continue
            dx = xi - pos[0,j]
            dy = yi - pos[1,j]
            dz = zi - pos[2,j]
            r2 = dx*dx + dy*dy + dz*dz + eps*eps
            r = np.sqrt(r2)
            invr3 = 1.0 / (r2 * r)
            s = -G * masses[j] * invr3
            ax += s*dx; ay += s*dy; az += s*dz
            if yukawa_k != 0.0:
                sgn = 1.0 if yukawa_repulsive else -1.0
                fac = sgn * yukawa_k * np.exp(-yukawa_lambda * r) * (1.0/(r*r) + yukawa_lambda/r) / r
                fac *= masses[j]
                ax += fac*dx; ay += fac*dy; az += fac*dz
        # center
        r2c = xi*xi + yi*yi + zi*zi
        ax += -(center_k * masses[i]) * xi
        ay += -(center_k * masses[i]) * yi
        az += -(center_k * masses[i]) * zi
        invr3c = 1.0 / ((r2c + center_eps*center_eps)**1.5)
        sC = -(center_GM * masses[i]) * invr3c
        ax += sC*xi; ay += sC*yi; az += sC*zi
        acc[0,i] = ax; acc[1,i] = ay; acc[2,i] = az
    return acc

# 백엔드 선택기
def _acc_full(pos, vel, G, masses, eps,
              nu_eff, turb_coeff, k_ctrl_eff, theta_dev,
              center_k, center_GM, center_eps, ctrl_signed,
              yukawa_k, yukawa_lambda, yukawa_repulsive):
    if CEXT is not None:
        return CEXT.accelerations(pos, vel, G, masses, eps,
                                  nu_eff, turb_coeff, k_ctrl_eff, theta_dev,
                                  center_k, center_GM, center_eps, bool(ctrl_signed),
                                  yukawa_k, yukawa_lambda, bool(yukawa_repulsive))
    if HAVE_NUMBA:
        return accelerations_numba_full(pos, vel, G, masses, eps,
                                        nu_eff, turb_coeff, k_ctrl_eff, theta_dev,
                                        center_k, center_GM, center_eps, ctrl_signed,
                                        yukawa_k, yukawa_lambda, yukawa_repulsive)
    return accelerations_np_full(pos, vel, G, masses, eps,
                                 nu_eff, turb_coeff, k_ctrl_eff, theta_dev,
                                 center_k, center_GM, center_eps,
                                 ctrl_signed, yukawa_k, yukawa_lambda, yukawa_repulsive)

def _acc_cons(pos, vel, G, masses, eps,
              center_k, center_GM, center_eps, yukawa_k, yukawa_lambda, yukawa_repulsive):
    if CEXT is not None:
        return CEXT.accelerations_cons(pos, vel, G, masses, eps,
                                       center_k, center_GM, center_eps,
                                       yukawa_k, yukawa_lambda, bool(yukawa_repulsive))
    if HAVE_NUMBA:
        return accelerations_numba_conservative(pos, vel, G, masses, eps,
                                                center_k, center_GM, center_eps,
                                                yukawa_k, yukawa_lambda, yukawa_repulsive)
    return accelerations_np_conservative(pos, vel, G, masses, eps,
                                         center_k, center_GM, center_eps,
                                         yukawa_k, yukawa_lambda, yukawa_repulsive)

def _rmin(pos):
    """
    최소 거리 계산: CEXT(있으면) → Numba → NumPy 폴백
    pos shape: (3, N)
    """
    # 1) C 확장
    try:
        if CEXT is not None:
            return float(CEXT.min_pair_distance(pos))
    except NameError:
        pass
    except Exception:
        # CEXT가 있어도 호출 실패하면 폴백
        pass

    # 2) Numba
    try:
        if HAVE_NUMBA:
            return float(min_pair_distance_numba(pos))
    except NameError:
        pass
    except Exception:
        pass

    # 3) NumPy 폴백
    diffs = pos[:, None, :] - pos[:, :, None]  # (3,N,N)
    d2 = (diffs * diffs).sum(axis=0)           # (N,N)
    d2 = d2 + np.eye(d2.shape[0]) * 1e18       # 자기 자신 마스킹
    return float(np.sqrt(np.min(d2)))

# ================= Conservative RHS / Lyapunov =================
def rhs_body_conservative(t, s_body, args_rhs):
    G, masses, eps = args_rhs["G"], args_rhs["masses"], args_rhs["eps"]
    cK, cGM, cEps = args_rhs.get("center_k",0.0), args_rhs.get("center_GM",0.0), args_rhs.get("center_eps",0.1)
    yk = args_rhs.get("yukawa_k", 0.0); yl = args_rhs.get("yukawa_lambda", 0.5); yr = args_rhs.get("yukawa_repulsive", True)
    pos, vel = unpack_state_bodies(s_body, N=3)
    acc = _acc_cons(pos, vel, G, masses, eps, cK, cGM, cEps, yk, yl, yr)
    return pack_state_bodies(vel, acc)

def lyap_spectrum_benettin(s0_body, rhs_body, tmax=
# [ADD] next recenter time

12.0, dt=0.002, k=3, args_rhs=None, seed=0):
    rng = np.random.default_rng(seed)
    n = s0_body.size
    Q = rng.normal(size=(n, k)); Q, _ = np.linalg.qr(Q)
    lyap = np.zeros(k); t = 0.0; s = s0_body.copy()
    while t < tmax - 1e-12:
        t_next = min(t + dt, tmax)
        sol = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                        (t, t_next), s, method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
        s = sol.y[:, -1]
        eps_fd = 1e-8
        Z = np.zeros_like(Q)
        for j in range(k):
            sol2 = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                             (t, t_next), s + eps_fd*Q[:, j],
                             method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
            Z[:, j] = (sol2.y[:, -1] - s)/eps_fd
        Q, R = np.linalg.qr(Z)
        lyap += np.log(np.abs(np.diag(R)) + 1e-300)
        t = t_next
    return lyap / tmax

def benettin_light_max(s0_body, rhs_body, dt=0.01, renorm_every=50, tmax=12.0, args_rhs=None, seed=0):
    rng = np.random.default_rng(seed)
    v = rng.normal(size=s0_body.size); v /= np.linalg.norm(v)
    s = s0_body.copy()
    lam_sum, t, d0 = 0.0, 0.0, 1e-8
    s_pert = s + d0 * v
    while t < tmax - 1e-12:
        t_next = min(t + renorm_every * dt, tmax)
        sol1 = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                         (t, t_next), s, method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
        sol2 = solve_ivp(lambda tt, ss: rhs_body(tt, ss, args_rhs),
                         (t, t_next), s_pert, method="DOP853", rtol=1e-9, atol=1e-12, max_step=dt)
        s = sol1.y[:, -1]; s_pert = sol2.y[:, -1]
        d = np.linalg.norm(s_pert - s); d = d if d > 0 else 1e-300
        lam_sum += np.log(d/d0)
        v = (s_pert - s) / d
        s_pert = s + d0 * v
        t = t_next
    T = max(t, 1e-30)
    return lam_sum / T

# ========================== DTG RHS ==========================
class RHSParams:
    def __init__(self, G, masses, eps,
                 nu0=0.0, nu_max=1.0, turb_coeff=0.0,
                 theta0=1.0, alpha_dtg=0.4, beta_dtg=0.5, b_dtg=0.0, tau_theta=3.0,
                 theta_min=-1.5, theta_max=1.5, dtheta_max=0.05,
                 k_nu=0.0, k_nu_ed=0.0, k_ctrl=0.0, k_ctrl_e=0.0,
                 lyap_const=0.0, E0=None, soften_ctrl_when_clamped=True,
                 center_k=0.0, center_GM=0.0, center_eps=0.1,
                 gate_floor=0.30, ctrl_signed=False,
                 yukawa_k=0.0, yukawa_lambda=0.5, yukawa_repulsive=True,
                 res_amp=0.0, res_omega=0.0, ed_scale=0.1, k_planar=0.0):
        self.G = float(G)
        self.masses = np.asarray(masses, float)
        self.eps = float(eps)

        self.nu0 = float(nu0)
        self.nu_max = float(nu_max)
        self.turb_coeff = float(turb_coeff)

        self.theta0 = float(theta0)
        self.alpha_dtg = float(alpha_dtg)
        self.beta_dtg = float(beta_dtg)
        self.b_dtg = float(b_dtg)
        self.tau_theta = float(tau_theta)

        self.theta_min = float(theta_min)
        self.theta_max = float(theta_max)
        self.dtheta_max = float(dtheta_max)

        self.k_nu = float(k_nu)
        self.k_nu_ed = float(k_nu_ed)
        self.k_ctrl = float(k_ctrl)
        self.k_ctrl_e = float(k_ctrl_e)

        self.lyap_const = float(lyap_const)
        self.E0 = None if E0 is None else float(E0)
        self.soften_ctrl_when_clamped = bool(soften_ctrl_when_clamped)

        self.center_k = float(center_k)
        self.center_GM = float(center_GM)
        self.center_eps = float(center_eps)

        self.gate_floor = float(gate_floor)
        self.ctrl_signed = bool(ctrl_signed)

        # clamp scale for energy deviation feedback
        self.ed_scale = float(ed_scale)

        self.yukawa_k = float(yukawa_k)
        self.yukawa_lambda = float(yukawa_lambda)
        self.yukawa_repulsive = bool(yukawa_repulsive)

        self.res_amp = float(res_amp)
        self.res_omega = float(res_omega)

def rhs_with_dtg(t, s_all, prm):
    pos, vel, theta = split_state_with_theta(s_all, N=3)

    # Energy deviation ed
    if prm.E0 is not None:
        E = total_energy_body(pack_state_bodies(pos, vel), prm.G, prm.masses, eps=prm.eps,
                              center_k=prm.center_k, center_GM=prm.center_GM, center_eps=prm.center_eps,
                              yukawa_k=prm.yukawa_k, yukawa_lambda=prm.yukawa_lambda, yukawa_repulsive=prm.yukawa_repulsive)
        ed = (E - prm.E0) / (abs(prm.E0) + 1e-15)
    else:
        ed = 0.0

    # DTG target (+ resonance)
    res_term = prm.res_amp * np.sin(prm.res_omega * t) if prm.res_amp != 0.0 and prm.res_omega != 0.0 else 0.0
    ed_eff = np.tanh(ed / max(1e-12, prm.ed_scale))
    target = prm.theta0 + prm.alpha_dtg*ed_eff - prm.beta_dtg*prm.lyap_const + res_term
    dtheta_raw = (target - theta) / max(prm.tau_theta, 1e-9)
    dtheta = np.clip(dtheta_raw, -prm.dtheta_max, prm.dtheta_max)

    theta_clamped = np.clip(theta, prm.theta_min, prm.theta_max)
    theta_dev = theta_clamped - prm.theta0
    nu_eff = np.clip(prm.nu0 + prm.k_nu*theta_dev + prm.k_nu_ed*ed, 0.0, prm.nu_max)

    k_ctrl_eff = prm.k_ctrl * (1.0 + prm.k_ctrl_e*abs(ed))
    if prm.soften_ctrl_when_clamped and (theta != theta_clamped):
        k_ctrl_eff *= 0.5

    # Close-approach gating with floor
    rmin_now = _rmin(pos)
    r_lo, r_hi = 0.03, 0.20
    r_mid = 0.5*(r_lo + r_hi)
    w = max(1e-12, (r_hi - r_lo)/6.0)
    g = 1.0/(1.0 + np.exp(-(rmin_now - r_mid)/w))  # 0..1
    k_ctrl_eff *= prm.gate_floor + (1.0 - prm.gate_floor) * (1.0 - g)

    # accelerations (full)
    acc = _acc_full(pos, vel, prm.G, prm.masses, prm.eps,
                    float(nu_eff), float(prm.turb_coeff), float(k_ctrl_eff), float(theta_dev),
                    float(prm.center_k), float(prm.center_GM), float(prm.center_eps),
                    bool(prm.ctrl_signed),
                    float(prm.yukawa_k), float(prm.yukawa_lambda), bool(prm.yukawa_repulsive))
    # apply planar spring (z-axis) after backend force
    if getattr(prm, "k_planar", 0.0) != 0.0:
        acc[2, :] -= prm.k_planar * pos[2, :]
    return np.concatenate([pack_state_bodies(vel, acc), np.array([dtheta])])

# ========================== Symplectic (K–D–K) ==========================
def dissipative_kick_inplace(pos, vel, dt, nu_eff, k_ctrl_eff, theta_dev, turb_coeff, ctrl_signed):
    # per-body damping factor: nu + k_ctrl*td  (turbulence acts as multiplicative +-)
    r2 = np.sum(pos*pos, axis=0)
    td = theta_dev if ctrl_signed else np.maximum(theta_dev, 0.0)
    damp = (nu_eff + k_ctrl_eff*td)
    # [muted] if turb_coeff != 0.0:
        # [muted] damp -= turb_coeff * np.sin(r2)  # 원래 +turb*vel 이므로, v' = v + dt*turb*vel ≈ (1 + dt*turb)*v
        # [muted] # 여기선 split에서 대칭 맞추기 위해 −부호로 넣고 양 끝에서 반씩 적용
    factor = (1.0 - 0.5*dt*damp)
    vel *= factor[None, :] if np.ndim(factor) else factor
def symplectic_step(pos, vel, dt, prm, th):
    # 현재 θ 편차(클램프 포함)
    theta_dev = (min(max(th, prm.theta_min), prm.theta_max) - prm.theta0)

    # half dissipative kick
    dissipative_kick_inplace(pos, vel, dt, prm.nu0, prm.k_ctrl, theta_dev,
                             prm.turb_coeff, prm.ctrl_signed)

    # conservative half-kick
    acc = _acc_cons(pos, vel, prm.G, prm.masses, prm.eps,
                    prm.center_k, prm.center_GM, prm.center_eps,
                    prm.yukawa_k, prm.yukawa_lambda, prm.yukawa_repulsive)
    vel += 0.5*dt*acc
    # drift
    pos += dt*vel
    # conservative half-kick
    acc2 = _acc_cons(pos, vel, prm.G, prm.masses, prm.eps,
                     prm.center_k, prm.center_GM, prm.center_eps,
                     prm.yukawa_k, prm.yukawa_lambda, prm.yukawa_repulsive)
    vel += 0.5*dt*acc2

    # 다시 한 번 최신 θ로 half dissipative kick (동일 th 사용)
    theta_dev2 = (min(max(th, prm.theta_min), prm.theta_max) - prm.theta0)
    dissipative_kick_inplace(pos, vel, dt, prm.nu0, prm.k_ctrl, theta_dev2,
                             prm.turb_coeff, prm.ctrl_signed)
    return pos, vel

    # conservative half-kick
    acc = _acc_cons(pos, vel, prm.G, prm.masses, prm.eps,
                    prm.center_k, prm.center_GM, prm.center_eps,
                    prm.yukawa_k, prm.yukawa_lambda, prm.yukawa_repulsive)
    # apply planar spring (z-axis) to conservative acc
    if getattr(prm, "k_planar", 0.0) != 0.0:
        acc[2, :] -= prm.k_planar * pos[2, :]
    vel += 0.5*dt*acc
    # drift
    pos += dt*vel
    # conservative half-kick
    acc2 = _acc_cons(pos, vel, prm.G, prm.masses, prm.eps,
                     prm.center_k, prm.center_GM, prm.center_eps,
                     prm.yukawa_k, prm.yukawa_lambda, prm.yukawa_repulsive)
    # apply planar spring (z-axis) to conservative acc2
    if getattr(prm, "k_planar", 0.0) != 0.0:
        acc2[2, :] -= prm.k_planar * pos[2, :]
    vel += 0.5*dt*acc2

    # half dissipative kick
    dissipative_kick_inplace(pos, vel, dt, prm.nu0, prm.k_ctrl, 0.0, prm.turb_coeff, prm.ctrl_signed)
    return pos, vel

def integrate_symplectic(t0, t1, y0, args, prm):
    # 간단한 KDK + theta는 ODE로 별도 적분(전진 오일러; dt가 작으면 충분)
    pos, vel, theta = split_state_with_theta(y0)
    T = np.arange(t0, t1 + 1e-12, args.dt)
    Y = np.empty((y0.size, T.size), dtype=float)
    Y[:, 0] = y0
    th = float(theta)
    for k in range(1, T.size):
        t_prev = T[k-1]
        # θ는 rhs_with_dtg의 dtheta를 사용해 업데이트(vel/pos는 심플렉틱으로)
        # target, ed 등 계산 위해 rhs 호출하되, 그 안의 acc는 쓰지 않고 dtheta만 이용
        dtheta = rhs_with_dtg(t_prev, np.concatenate([pack_state_bodies(pos, vel), np.array([th])]), prm)[-1]
        # 한 스텝
        pos, vel = symplectic_step(pos, vel, args.dt, prm, th)
        th = np.clip(th + args.dt * dtheta, prm.theta_min, prm.theta_max)
        Y[:, k] = np.concatenate([pack_state_bodies(pos, vel), np.array([th])])
    return T, Y

# ========================== Core integration (adaptive optional for DOP) ==========================
def integrate_with_optional_adaptive(rhs, t0, t1, y0, args, prm, events):
    if args.use_symplectic:
        return integrate_symplectic(t0, t1, y0, args, prm), dict(escaped=False, t_escape=None, collided=False, t_collision=None)

    cur_t = float(t0)
    cur_y = y0.copy()
    cur_max_step = args.dt
    T_list = [cur_t]
    Y_list = [cur_y]
    escaped = collided = False
    t_escape = t_collision = None

    while cur_t < t1 - 1e-12:
        t_next = min(cur_t + args.chunk, t1)
        sol = solve_ivp(lambda tt, ss: rhs(tt, ss, prm),
                        (cur_t, t_next), cur_y, t_eval=None,
                        events=events,
                        method="DOP853", rtol=1e-9, atol=1e-12, max_step=cur_max_step)
        if sol.t.size > 1:
            T_list.extend(sol.t[1:])
            Y_list.extend(sol.y[:,1:].T)
        cur_t = float(T_list[-1]); cur_y = Y_list[-1]

        if len(sol.t_events) >= 1 and len(sol.t_events[0]) > 0:
            escaped = True; t_escape = float(sol.t_events[0][0]); break
        if len(sol.t_events) >= 2 and len(sol.t_events[1]) > 0:
            collided = True; t_collision = float(sol.t_events[1][0]); break

        if args.adaptive_step:
            pos, _, _ = split_state_with_theta(cur_y)
            rmin = _rmin(pos)
            if rmin < args.adapt_r_trigger:
                cur_max_step = max(args.min_max_step, cur_max_step * args.adapt_factor)
            else:
                cur_max_step = min(args.dt, cur_max_step / max(1e-12, args.adapt_factor))

    T = np.array(T_list); Y = np.stack(Y_list, axis=1)
    return (T, Y), dict(escaped=escaped, t_escape=t_escape, collided=collided, t_collision=t_collision)

# ========================== Energies ==========================
def total_energy_body(s_body, G=1.0, masses=(1,1,1), eps=DEFAULT_EPS,
                      center_k=0.0, center_GM=0.0, center_eps=0.1,
                      yukawa_k=0.0, yukawa_lambda=0.5, yukawa_repulsive=True):
    pos, vel = unpack_state_bodies(s_body, N=3)
    masses = np.asarray(masses, float)
    # Kinetic
    K = 0.5 * np.sum(masses * np.sum(vel*vel, axis=0))
    # Pairwise potential: Newton + Yukawa + center
    dr, r2 = pairwise_dr(pos)
    r = np.sqrt(r2 + eps*eps)
    iu = np.triu_indices(len(masses), 1)
    U_pairs = -G * np.sum(masses[iu[0]] * masses[iu[1]] / r[iu])

    if yukawa_k != 0.0:
        sgn = +1.0 if yukawa_repulsive else -1.0
        U_y = sgn * yukawa_k * np.sum(np.exp(-yukawa_lambda * r[iu]) / r[iu] * (masses[iu[0]]*masses[iu[1]]))
    else:
        U_y = 0.0

    r2_self = np.sum(pos*pos, axis=0)  # (N,)
    U_center_h = 0.5 * np.sum(masses * center_k * r2_self)
    U_center_p = - np.sum(center_GM * masses / np.sqrt(r2_self + center_eps**2))
    return K + U_pairs + U_y + U_center_h + U_center_p

# ========================== Run simulation ==========================
def hold_true(x_bool, win):
    """
    x_bool: bool ndarray (시간축 1D)
    win   : 연속 유지해야 하는 샘플 수 (int >=1)
    """
    import numpy as np
    x = np.asarray(x_bool, dtype=bool).ravel()
    w = int(max(1, win))
    if x.size == 0: 
        return False
    cur = 0
    for b in x:
        cur = cur + 1 if b else 0
        if cur >= w:
            return True
    return False
def diag_planarity(z, tol=1e-3):
    """z 최대 절댓값이 tol보다 작으면 평면성 True."""
    import numpy as np
    z = np.asarray(z)
    zmax = float(np.max(np.abs(z))) if z.size else 0.0
    return bool(zmax < tol), zmax
def diag_fig8_similarity_phase(x, y, eps=1e-12):
    """세 궤적의 진행각 변화(unwrap) 표준화 후 페어 간 표준편차 합(낮을수록 유사)."""
    import numpy as np
    scores = []
    for i in range(3):
        dx = np.diff(x[i]); dy = np.diff(y[i])
        ang = np.arctan2(dy + 0.0, dx + eps)
        dang = np.unwrap(ang)
        std = np.std(dang) + eps
        z = (dang - dang.mean()) / std
        scores.append(z)
    def pair_score(a, b):
        n = min(len(a), len(b))
        a = a[:n]; b = b[:n]
        return float(np.std(a - b))
    return pair_score(scores[0], scores[1]) + pair_score(scores[1], scores[2]) + pair_score(scores[0], scores[2])

def run_simulation(args):

    if args.eps < 1e-10:
        print(f"[warn] eps={args.eps:g} is very small; risk of blow-up near close encounters.")

    os.makedirs(args.out, exist_ok=True)
    for sub in ["figures", "data", "meta"]:
        os.makedirs(os.path.join(args.out, sub), exist_ok=True)

    masses = np.array([1.0,1.0,1.0], float)
    pos0, vel0 = make_ic(args.ic, args.alpha)
    if args.zero_init:
        pos0, vel0 = zero_com_and_momentum(pos0, vel0, masses)

    s0_body = pack_state_bodies(pos0, vel0)
    E0 = total_energy_body(
        s0_body, args.G, masses, eps=args.eps,
        center_k=args.center_k, center_GM=args.center_GM, center_eps=args.center_eps,
        yukawa_k=args.yukawa_k, yukawa_lambda=args.yukawa_lambda, yukawa_repulsive=args.yukawa_repulsive
    )

    # Lyapunov (conservative system only)
    lyap_top = None; lyap_spec = None
    if args.lyap_light:
        lyap_top = benettin_light_max(
            s0_body, rhs_body_conservative,
            dt=args.lyap_light_dt, renorm_every=args.lyap_light_renorm,
            tmax=max(6.0, args.tmax),
            args_rhs=dict(
                G=args.G, masses=masses, eps=args.eps,
                center_k=args.center_k, center_GM=args.center_GM, center_eps=args.center_eps,
                yukawa_k=args.yukawa_k, yukawa_lambda=args.yukawa_lambda, yukawa_repulsive=args.yukawa_repulsive
            ),
            seed=args.seed
        )
        print(f"[Lyapunov(top, light) ≈] {lyap_top:.6f}")
    if args.lyap_spectrum:
        lyap_spec = lyap_spectrum_benettin(
            s0_body, rhs_body_conservative,
            tmax=max(6.0, args.tmax), dt=args.dt, k=args.lyap_k,
            args_rhs=dict(
                G=args.G, masses=masses, eps=args.eps,
                center_k=args.center_k, center_GM=args.center_GM, center_eps=args.center_eps,
                yukawa_k=args.yukawa_k, yukawa_lambda=args.yukawa_lambda, yukawa_repulsive=args.yukawa_repulsive
            ),
            seed=args.seed
        )
        print("[Lyapunov spectrum (top-k)]", " ".join(f"{v:.6f}" for v in lyap_spec))

    if lyap_spec is not None:
        lyap_score = float(np.sum([v for v in lyap_spec if v > 0]))
        lyap_const = float(lyap_spec[0])
    elif lyap_top is not None:
        lyap_score = float(max(0.0, lyap_top))
        lyap_const = float(lyap_top)
    else:
        lyap_score = 0.0
        lyap_const = float(args.lyap_const)

    prm = RHSParams(
        G=args.G, masses=masses, eps=args.eps,
        nu0=args.nu0, nu_max=args.nu_max, turb_coeff=args.turb,
        theta0=args.theta0, alpha_dtg=args.alpha_dtg, beta_dtg=args.beta_dtg,
        b_dtg=args.b_dtg, tau_theta=args.tau_theta,
        theta_min=args.theta_min, theta_max=args.theta_max, dtheta_max=args.dtheta_max,
        k_nu=args.k_nu, k_nu_ed=args.k_nu_ed, k_ctrl=args.k_ctrl, k_ctrl_e=args.k_ctrl_e,
        lyap_const=lyap_const, E0=(E0 if args.dtg else None),
        soften_ctrl_when_clamped=not args.no_soften_when_clamped,
        center_k=args.center_k, center_GM=args.center_GM, center_eps=args.center_eps,
        gate_floor=args.gate_floor, ctrl_signed=args.ctrl_signed,
        k_planar=getattr(args,"k_planar",0.0),
        ed_scale=args.ed_scale,
        yukawa_k=args.yukawa_k, yukawa_lambda=args.yukawa_lambda, yukawa_repulsive=args.yukawa_repulsive,
        res_amp=args.res_amp, res_omega=args.res_omega
    )

    t_eval = np.arange(0.0, args.tmax + 1e-12, args.dt)
    theta_init = args.theta0 if (args.theta_init is None) else float(args.theta_init)
    s_all = np.concatenate([s0_body, np.array([theta_init])])

    # Events (DOP 전용; 심플렉틱 경로는 후처리 판단)
    def event_escape(t, s):
        pos, _, _ = split_state_with_theta(s, N=3)
        r = np.sqrt(np.sum(pos*pos, axis=0))
        return float(args.R_esc - np.max(r))
    event_escape.terminal = True; event_escape.direction = -1.0

    def event_collision(t, s):
        pos, _, _ = split_state_with_theta(s, N=3)
        return _rmin(pos) - args.r_collide
    event_collision.terminal = True; event_collision.direction = -1.0

    (T, Y), events_info = integrate_with_optional_adaptive(
        rhs_with_dtg, 0.0, args.tmax, s_all, args, prm, (event_escape, event_collision)
    )
    if args.use_symplectic:
        # 심플렉틱은 연속 이벤트 감지는 생략했으므로 최종 판정만
        pos_end, _, _ = split_state_with_theta(Y[:,-1], N=3)
        r_end = np.sqrt(np.sum(pos_end*pos_end, axis=0)).max()
        if r_end > args.R_esc: events_info.update(escaped=True, t_escape=T[-1])
        if _rmin(pos_end) < args.r_collide: events_info.update(collided=True, t_collision=T[-1])

    bodyY, theta_hist = Y[:-1, :], Y[-1, :]
    x, y, z = positions_from_sol_bodyY(bodyY, N=3)

    # ===== Vectorized diagnostics =====
    def compute_diagnostics(bodyY, masses, G, eps, center_k, center_GM, center_eps,
                            yukawa_k, yukawa_lambda, yukawa_repulsive):
        pos = bodyY[:9, :].reshape(3, 3, -1, order="F")
        vel = bodyY[9:18, :].reshape(3, 3, -1, order="F")
        speed2 = np.sum(vel**2, axis=0)                    # (body, T)
        K = 0.5 * np.sum(masses[:, None] * speed2, axis=0) # (T,)
        dr = pos[:, None, :, :] - pos[:, :, None, :]       # (xyz, i, j, T)
        r2 = np.sum(dr**2, axis=0)                         # (i, j, T)
        r2_off = r2 + np.eye(3)[:, :, None] * 1e18
        r = np.sqrt(r2_off + eps*eps)
        iu = np.triu_indices(3, 1)
        pair_mass = (masses[iu[0]] * masses[iu[1]])[:, None]
        U_pairs = -G * np.sum(pair_mass / r[iu], axis=0)   # (T,)
        # Yukawa energy
        if yukawa_k != 0.0:
            sgn = +1.0 if yukawa_repulsive else -1.0
            U_y = sgn * yukawa_k * np.sum(np.exp(-yukawa_lambda * r[iu]) / r[iu] * pair_mass, axis=0)
        else:
            U_y = 0.0
        r2_self = np.sum(pos*pos, axis=0)                  # (body, T)
        U_center_h = 0.5 * np.sum(masses[:,None] * center_k * r2_self, axis=0)
        U_center_p = - np.sum(center_GM * masses[:,None] / np.sqrt(r2_self + center_eps**2), axis=0)
        E_series = K + U_pairs + U_y + U_center_h + U_center_p
        rmin_series = np.sqrt(np.min(r2_off, axis=(0,1)))
        return E_series, rmin_series

    masses_arr = np.array([1.0,1.0,1.0], float)
    E_series, rmin_series = compute_diagnostics(bodyY, masses_arr, args.G, args.eps,
                                                args.center_k, args.center_GM, args.center_eps,
                                                args.yukawa_k, args.yukawa_lambda, args.yukawa_repulsive)
    drift = (E_series - E0) / (abs(E0) + 1e-15)

    def pairdist(a,b):
        return np.sqrt((x[a]-x[b])**2 + (y[a]-y[b])**2 + (z[a]-z[b])**2)
    r12, r13, r23 = pairdist(0,1), pairdist(0,2), pairdist(1,2)
    bin_window = max(1, int(args.bin_hold/args.dt))
    binary_flag = any(hold_true(r < args.r_bin, bin_window) for r in [r12, r13, r23])

    # ===== CSVs =====
    df_main = pd.DataFrame({
        "t": T,
        "x1": x[0], "y1": y[0], "z1": z[0],
        "x2": x[1], "y2": y[1], "z2": z[1],
        "x3": x[2], "y3": y[2], "z3": z[2],
        "theta": theta_hist
    })
    csv_path = os.path.join(args.out, "data", f"threebody3d_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.csv")
    df_main.to_csv(csv_path, index=False)

    df_diag = pd.DataFrame({
        "t": T, "energy": E_series, "drift": drift,
        "rmin": rmin_series, "r12": r12, "r13": r13, "r23": r23,
        "theta": theta_hist
    })
    csv_diag = os.path.join(args.out, "data", f"diagnostics_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.csv")
    df_diag.to_csv(csv_diag, index=False)

    # ===== Plots =====
    if not args.no_plots:
        fig = plt.figure(figsize=(7,6)); ax = fig.add_subplot(111, projection="3d")
        ax.plot(x[0],y[0],z[0],label="Body 1"); ax.plot(x[1],y[1],z[1],label="Body 2"); ax.plot(x[2],y[2],z[2],label="Body 3")
        ax.set_xlabel("X"); ax.set_ylabel("Y"); ax.set_zlabel("Z")
        ax.set_title(f"3D Three-Body (ic={args.ic}, α={args.alpha}, dtg={args.dtg})")
        ax.legend();
        try:
            ax.set_box_aspect((1,1,1)); ax.set_proj_type('ortho')
        except Exception:
            pass
        ax.view_init(elev=args.elev, azim=args.azim)
        fig3d = os.path.join(args.out, "figures", f"threebody3d_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.png")
        fig.savefig(fig3d, dpi=160); plt.close(fig)

        plt.figure(figsize=(6,5))
        for i, lab in enumerate(["Body 1","Body 2","Body 3"]):
            plt.plot(x[i], y[i], label=lab)
        plt.axis("equal"); plt.xlabel("X"); plt.ylabel("Y"); plt.legend()
        fig_xy = os.path.join(args.out, "figures", f"xy_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.png")
        plt.savefig(fig_xy, dpi=160); plt.close()

        plt.figure(figsize=(7,4)); plt.plot(T, drift); plt.xlabel("Time"); plt.ylabel("Relative Energy Drift")
        fig_drift = os.path.join(args.out, "figures", f"energy_drift_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.png")
        plt.savefig(fig_drift, dpi=160); plt.close()

        plt.figure(figsize=(7,4)); plt.plot(T, theta_hist); plt.xlabel("Time"); plt.ylabel("Theta (DTG)")
        fig_theta = os.path.join(args.out, "figures", f"theta_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.png")
        plt.savefig(fig_theta, dpi=160); plt.close()

        plt.figure(figsize=(7,4)); plt.plot(T, rmin_series, label="rmin")
        plt.plot(T, r12, label="r12"); plt.plot(T, r13, label="r13"); plt.plot(T, r23, label="r23")
        plt.xlabel("Time"); plt.ylabel("Pair Distances"); plt.legend()
        fig_dist = os.path.join(args.out, "figures", f"distances_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.png")
        plt.savefig(fig_dist, dpi=160); plt.close()
    else:
        fig3d = fig_drift = fig_theta = fig_xy = fig_dist = None

    # ===== High-level diagnostics =====
    planar, zmax = diag_planarity(z)
    fig8_phase = diag_fig8_similarity_phase(x, y)

    # θ activity (rad/s)
    dtheta = np.diff(theta_hist)
    dt_samp = float(np.mean(np.diff(T))) if len(T) > 1 else float(args.dt)
    theta_rate = float(np.mean(np.abs(dtheta)) / max(dt_samp, 1e-12))

    meta = dict(
        timestamp=time.strftime("%Y-%m-%d %H:%M:%S"),
        args=vars(args),
        backend=BACKEND,
        E0=float(E0),
        lyap_top=float(lyap_top) if lyap_top is not None else None,
        lyap_spectrum=(list(map(float, lyap_spec)) if lyap_spec is not None else None),
        lyap_score=float(lyap_score),
        outputs=dict(csv=csv_path, csv_diagnostics=csv_diag,
                     fig3d=(None if args.no_plots else fig3d),
                     fig_xy=(None if args.no_plots else fig_xy),
                     drift=(None if args.no_plots else fig_drift),
                     theta=(None if args.no_plots else fig_theta),
                     distances=(None if args.no_plots else fig_dist)),
        events=events_info,
        binary=dict(flag=bool(binary_flag), r_bin=float(args.r_bin), hold=float(args.bin_hold)),
        end_state=dict(rmin=float(rmin_series[-1]),
                       drift=float(drift[-1]),
                       theta=float(theta_hist[-1]),
                       planar=planar, zmax=zmax,
                       fig8_phase=float(fig8_phase),
                       theta_activity=theta_rate)
    )

    meta["provenance"] = dict(
        python=sys.version, platform=platform.platform(),
        numpy=np.__version__, pandas=pd.__version__, cmd=" ".join(sys.argv)
    )
    try:
        import scipy
        meta["provenance"]["scipy"] = scipy.__version__
    except Exception:
        pass

    meta_path = os.path.join(args.out, "meta", f"meta_{args.ic}_a{args.alpha}_dtg{int(args.dtg)}.json")
    with open(meta_path, "w", encoding="utf-8") as f:
        json.dump(meta, f, ensure_ascii=False, indent=2)

    print(f"[OK] CSV   : {csv_path}")
    print(f"[OK] DIAG  : {csv_diag}")
    if meta["events"]["escaped"]:
        print(f"[event] escape at t≈{meta['events']['t_escape']:.3f}")
    if meta["events"]["collided"]:
        print(f"[event] collision at t≈{meta['events']['t_collision']:.3f}")
    if binary_flag:
        print(f"[info] binary formation detected (any pair r<{args.r_bin}, hold≥{args.bin_hold}s)")

    lam_list = (lyap_spec if lyap_spec is not None else ([lyap_top] if lyap_top is not None else []))
    return meta, csv_diag, lam_list, drift, theta_hist, planar, fig8_phase

# ========================== Analysis / Compare ==========================
def analyze_results(args, meta, csv_diag, lam, drift, theta_hist, planar, fig8_phase):
    max_drift = float(np.max(np.abs(drift)))
    has_dissipation = (args.nu0 > 0) or (args.k_ctrl > 0) or (args.k_nu > 0) or (args.k_ctrl_e > 0)
    if has_dissipation:
            has_dissipation = (args.nu0 > 0) or (args.k_ctrl > 0) or (args.k_nu > 0) or (args.k_ctrl_e > 0)
    if has_dissipation:
        drift_good = (max_drift < max(args.drift_threshold, 0.5))
    else:
        drift_good = (max_drift < args.drift_threshold)

def compare_runs(args, csv_b, csv_d, meta_b, meta_d):
    b = pd.read_csv(csv_b); d = pd.read_csv(csv_d)
    b_max = b["drift"].abs().max(); d_max = d["drift"].abs().max()
    imp_drift = 100*(b_max - d_max)/max(1e-12, b_max)

    esc_b = 0 if meta_b["events"]["escaped"] else 1
    esc_d = 0 if meta_d["events"]["escaped"] else 1
    imp_escape = 100*(esc_d - esc_b)

    col_b = 0 if meta_b["events"]["collided"] else 1
    col_d = 0 if meta_d["events"]["collided"] else 1
    imp_collision = 100*(col_d - col_b)

    lam_b = meta_b["lyap_top"] or (meta_b.get("lyap_spectrum",[0])[0] if meta_b.get("lyap_spectrum") else 0)
    lam_d = meta_d["lyap_top"] or (meta_d.get("lyap_spectrum",[0])[0] if meta_d.get("lyap_spectrum") else 0)
    imp_lyap = 100*(lam_b - lam_d)/max(1e-12, lam_b) if lam_b else 0

    dtheta = np.diff(d["theta"].values)
    dt_samp = float(np.mean(np.diff(d["t"].values))) if len(d["t"].values) > 1 else float(args.dt)
    theta_rate = float(np.mean(np.abs(dtheta)) / max(dt_samp, 1e-12))
    theta_active = theta_rate > 0.01

    score = sum(v > 30 for v in [imp_drift, imp_escape, imp_collision, imp_lyap]) + int(theta_active)
    verdict = "PASS" if score >= 2 else "NO-GAIN"
    return dict(
        verdict=verdict,
        drift_improve=float(imp_drift),
        escape_improve=float(imp_escape),
        collision_improve=float(imp_collision),
        lyap_improve=float(imp_lyap),
        theta_active=bool(theta_active)
    )

# ========================== IC / helpers ==========================
def make_ic(mode="exp2", alpha=1.0):
    if mode == "exp1":
        raw = [0,0,0, 0,0,0, 1,0,0, 0,0.6,0.1, -1,0,0, 0,-0.6,-0.1]
    elif mode == "exp2":
        raw = [0,0,0, 0,0,0, 1,0,0, 0,0.8,0.2, -1,0,0, 0,-0.5,-0.05]
    elif mode == "exp3":
        raw = [0,0,0, 0,0,0, 1,0,0, 0,1.0,0.4, -1,0,0, 0,-0.2,0.0]
    elif mode == "figure8":
        raw = [
            -0.97000436, 0.24308753, 0, 0.466203685, 0.43236573, 0,
             0.97000436,-0.24308753, 0, 0.466203685, 0.43236573, 0,
             0.0,        0.0,       0,-0.93240737,-0.86473146, 0
        ]
    else:
        raise ValueError("mode must be exp1|exp2|exp3|figure8")
    s = np.array(raw, float)
    pos = np.vstack([s[[0,6,12]], s[[1,7,13]], s[[2,8,14]]])
    vel = np.vstack([s[[3,9,15]], s[[4,10,16]], s[[5,11,17]]])
    vel *= alpha
    return pos, vel

def zero_com_and_momentum(pos, vel, masses):
    m = masses.reshape(1, -1)
    com = (pos*m).sum(axis=1)/m.sum()
    pos = pos - com.reshape(3,1)
    p = (vel*m).sum(axis=1, keepdims=True)
    vel = vel - p/m.sum()
    return pos, vel

def positions_from_sol_bodyY(Y, N=3):
    rows = np.arange(N)
    x_rows = 3*rows + 0; y_rows = 3*rows + 1; z_rows = 3*rows + 2
    return Y[x_rows, :], Y[y_rows, :], Y[z_rows, :]

# ============================ CLI ============================
def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--ic", choices=["exp1","exp2","exp3","figure8"], default="exp2")
    ap.add_argument("--alpha", type=float, default=1.0)
    ap.add_argument("--tmax", type=float, default=20.0)
    ap.add_argument("--dt", type=float, default=0.002)
    ap.add_argument("--out", default="runs/out")
    ap.add_argument("--elev", type=float, default=20.0)
    ap.add_argument("--azim", type=float, default=-60.0)
    ap.add_argument("--eps", type=float, default=DEFAULT_EPS)
    ap.add_argument("--G", type=float, default=1.0)
    ap.add_argument("--seed", type=int, default=0)
    ap.add_argument("--zero_init", action="store_true")
    ap.add_argument("--no_plots", action="store_true")
    ap.add_argument("--theta_init", type=float, default=None,
                    help="Initial theta value; default = theta0")
    ap.add_argument("--ctrl_signed", action="store_true",
                    help="Use signed control: ctrl ~ -k_ctrl_eff * theta_dev * v (instead of max(theta_dev,0))")

    # drag / turbulence
    ap.add_argument("--nu0", type=float, default=0.003)
    ap.add_argument("--nu_max", type=float, default=1.0)
    ap.add_argument("--turb", type=float, default=0.0)

    # DTG
    ap.add_argument("--dtg", type=int, default=1)
    ap.add_argument("--theta0", type=float, default=1.0)
    ap.add_argument("--alpha_dtg", type=float, default=0.4)
    ap.add_argument("--beta_dtg", type=float, default=0.5)
    ap.add_argument("--b_dtg", type=float, default=0.0)
    ap.add_argument("--tau_theta", type=float, default=3.0)
    ap.add_argument("--theta_min", type=float, default=-1.5)
    ap.add_argument("--theta_max", type=float, default=1.5)
    ap.add_argument("--dtheta_max", type=float, default=0.05)
    ap.add_argument("--k_nu", type=float, default=0.0)
    ap.add_argument("--k_nu_ed", type=float, default=0.0)
    ap.add_argument("--k_ctrl", type=float, default=0.0)
    ap.add_argument("--k_ctrl_e", type=float, default=0.0)
    ap.add_argument("--lyap_const", type=float, default=0.0)
    ap.add_argument("--no_soften_when_clamped", action="store_true")

    # NEW: central anchor
    ap.add_argument("--center_k", type=float, default=0.0, help="Harmonic anchor stiffness at origin")
    ap.add_argument("--center_GM", type=float, default=0.0, help="Plummer anchor GM at origin (G*M_center)")
    ap.add_argument("--center_eps", type=float, default=0.1, help="Plummer epsilon")
    ap.add_argument("--gate_floor", type=float, default=0.30, help="Close-approach gating minimum fraction for k_ctrl (0..1)")
    ap.add_argument("--k_planar", type=float, default=0.0, help="Planar spring strength (adds -k_planar*z to az)")
    ap.add_argument("--ed_scale", type=float, default=0.1, help="tanh clamp scale for energy deviation in DTG")
    # Yukawa
    ap.add_argument("--yukawa_k", type=float, default=0.0, help="Yukawa strength (0 disables)")
    ap.add_argument("--yukawa_lambda", type=float, default=0.5, help="Yukawa screening length")
    ap.add_argument("--yukawa_repulsive", action="store_true", help="Use repulsive Yukawa (default attractive if not set)")

    # Resonance
    ap.add_argument("--res_amp", type=float, default=0.0, help="DTG resonance amplitude")
    ap.add_argument("--res_omega", type=float, default=0.0, help="DTG resonance frequency")

    # events / binary
    ap.add_argument("--R_esc", type=float, default=10.0)
    ap.add_argument("--r_collide", type=float, default=1e-3)
    ap.add_argument("--r_bin", type=float, default=0.5)
    ap.add_argument("--bin_hold", type=float, default=1.0)

    # adaptive max_step outer loop (DOP only)
    ap.add_argument("--adaptive_step", action="store_true")
    ap.add_argument("--adapt_r_trigger", type=float, default=0.02)
    ap.add_argument("--adapt_factor", type=float, default=0.3, help="cur_max_step *= factor ( <1 shrink )")
    ap.add_argument("--min_max_step", type=float, default=2e-4)
    ap.add_argument("--chunk", type=float, default=0.5, help="seconds per outer integration chunk")

    # Integrator select
    ap.add_argument("--use_symplectic", action="store_true", help="Use K-D-K Verlet (with dissipation split)")

    # Lyapunov options
    ap.add_argument("--lyap_light", action="store_true")
    ap.add_argument("--lyap_light_dt", type=float, default=0.01)
    ap.add_argument("--lyap_light_renorm", type=int, default=50)
    ap.add_argument("--lyap_spectrum", action="store_true")
    ap.add_argument("--lyap_k", type=int, default=3)

    # compare & scans
    ap.add_argument("--compare", action="store_true")
    ap.add_argument("--nu_scan", type=float, nargs="*", default=[])

    # analysis threshold
    ap.add_argument("--drift_threshold", type=float, default=0.05)\n
ap.add_argument(
    "--recenter_mode",
    choices=["none","momentum","full"],
    default="none",
    help="Recenter COM periodically: none(off), momentum(zero COM V), full(zero COM R&V)",
)
ap.add_argument(
    "--recenter_period",
    type=float,
    default=60.0,
    help="Recenter interval in seconds",
)


    args = ap.parse_args()

    if args.compare:
        results = []
        scan_list = [args.nu0] + [nu for nu in args.nu_scan if nu != args.nu0]
        for nu in (scan_list or [0.003]):
            b_args = argparse.Namespace(**vars(args))
            b_args.dtg = 0; b_args.nu0 = nu; b_args.out = os.path.join(args.out, f"baseline_nu{nu}")
            meta_b, csv_b, lam_b, drift_b, theta_b, planar_b, fig8_b = run_simulation(b_args)

            d_args = argparse.Namespace(**vars(args))
            d_args.dtg = 1; d_args.nu0 = nu; d_args.out = os.path.join(args.out, f"dtg_nu{nu}")
            meta_d, csv_d, lam_d, drift_d, theta_d, planar_d, fig8_d = run_simulation(d_args)

            res = compare_runs(args, meta_b["outputs"]["csv_diagnostics"], meta_d["outputs"]["csv_diagnostics"], meta_b, meta_d)
            res.update(nu=nu, lyap_b=(lam_b[0] if lam_b else None), lyap_d=(lam_d[0] if lam_d else None))
            results.append(res)
            print(f"[COMPARE nu={nu}] verdict={res['verdict']} | "
                  f"drift={res['drift_improve']:.1f}% | escape={res['escape_improve']:.1f}% | "
                  f"collision={res['collision_improve']:.1f}% | lyap={res['lyap_improve']:.1f}% | "
                  f"theta_active={res['theta_active']}")

        if results:
            best = max(results, key=lambda r: (r["drift_improve"] + r["escape_improve"] +
                                               r["collision_improve"] + r["lyap_improve"]))
            print(f"[BEST] nu={best['nu']}, verdict={best['verdict']}")
        return

    meta, csv_diag, lam, drift, theta_hist, planar, fig8_phase = run_simulation(args)
    analyze_results(args, meta, csv_diag, lam, drift, theta_hist, planar, fig8_phase)

if __name__ == "__main__":
    print("[backend] %s" % ("Numba" if HAVE_NUMBA else "NumPy"))
    main()
